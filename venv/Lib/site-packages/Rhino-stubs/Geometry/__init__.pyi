from typing import Tuple, Set, Iterable, List


class AnnotationType:
    Unset = 0
    Aligned = 1
    Angular = 2
    Diameter = 3
    Radius = 4
    Rotated = 5
    Ordinate = 6
    ArcLen = 7
    CenterMark = 8
    Text = 9
    Leader = 10
    Angular3pt = 11


class Dimension(AnnotationBase):
    @AltPrefix.setter
    def AltPrefix(self, value: str) -> None: ...
    @property
    def AltSuffix(self) -> str: ...
    @AltSuffix.setter
    def AltSuffix(self, value: str) -> None: ...
    @property
    def AltZeroSuppression(self) -> ZeroSuppression: ...
    @AltZeroSuppression.setter
    def AltZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @property
    def AlternateBelowLine(self) -> bool: ...
    @AlternateBelowLine.setter
    def AlternateBelowLine(self, value: bool) -> None: ...
    @property
    def ToleranceFormat(self) -> ToleranceDisplayFormat: ...
    @ToleranceFormat.setter
    def ToleranceFormat(self, value: ToleranceDisplayFormat) -> None: ...
    @property
    def ToleranceResolution(self) -> int: ...
    @ToleranceResolution.setter
    def ToleranceResolution(self, value: int) -> None: ...
    @property
    def AltToleranceResolution(self) -> int: ...
    @AltToleranceResolution.setter
    def AltToleranceResolution(self, value: int) -> None: ...
    @property
    def ToleranceUpperValue(self) -> float: ...
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self, value: float) -> None: ...
    @property
    def ToleranceLowerValue(self) -> float: ...
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self, value: float) -> None: ...
    @property
    def ToleranceHeightScale(self) -> float: ...
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self, value: float) -> None: ...
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: LengthDisplay) -> None: ...
    def GetTextTransform(self, viewport: ViewportInfo, style: DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self, value: bool) -> None: ...
    @property
    def TextPosition(self) -> Point2d: ...
    @TextPosition.setter
    def TextPosition(self, value: Point2d) -> None: ...
    @property
    def PlainUserText(self) -> str: ...
    @property
    def TextFormula(self) -> str: ...
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @property
    def TextRotation(self) -> float: ...
    @TextRotation.setter
    def TextRotation(self, value: float) -> None: ...
    @property
    def NumericValue(self) -> float: ...
    @property
    def DetailMeasured(self) -> Guid: ...
    @DetailMeasured.setter
    def DetailMeasured(self, value: Guid) -> None: ...
    @property
    def DistanceScale(self) -> float: ...
    @DistanceScale.setter
    def DistanceScale(self, value: float) -> None: ...
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @ForceArrowPosition.setter
    def ForceArrowPosition(self, value: ForceArrow) -> None: ...
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @ForceTextPosition.setter
    def ForceTextPosition(self, value: ForceText) -> None: ...
    @property
    def ForceDimLine(self) -> bool: ...
    @ForceDimLine.setter
    def ForceDimLine(self, value: bool) -> None: ...
    @property
    def ArrowFit(self) -> ArrowFit: ...
    @ArrowFit.setter
    def ArrowFit(self, value: ArrowFit) -> None: ...
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self, value: bool) -> None: ...
    @property
    def TextFit(self) -> TextFit: ...
    @TextFit.setter
    def TextFit(self, value: TextFit) -> None: ...
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @TextOrientation.setter
    def TextOrientation(self, value: TextOrientation) -> None: ...
    @property
    def TextLocation(self) -> TextLocation: ...
    @TextLocation.setter
    def TextLocation(self, value: TextLocation) -> None: ...
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @TextAngleType.setter
    def TextAngleType(self, value: LeaderContentAngleStyle) -> None: ...
    @property
    def DimensionLineExtension(self) -> float: ...
    @DimensionLineExtension.setter
    def DimensionLineExtension(self, value: float) -> None: ...
    @property
    def ExtensionLineExtension(self) -> float: ...
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self, value: float) -> None: ...
    @property
    def ExtensionLineOffset(self) -> float: ...
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self, value: float) -> None: ...
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self, value: bool) -> None: ...
    @property
    def FixedExtensionLength(self) -> float: ...
    @FixedExtensionLength.setter
    def FixedExtensionLength(self, value: float) -> None: ...
    @property
    def BaselineSpacing(self) -> float: ...
    @BaselineSpacing.setter
    def BaselineSpacing(self, value: float) -> None: ...
    @property
    def CentermarkSize(self) -> float: ...
    @CentermarkSize.setter
    def CentermarkSize(self, value: float) -> None: ...
    @property
    def CentermarkStyle(self) -> CenterMarkStyle: ...
    @CentermarkStyle.setter
    def CentermarkStyle(self, value: CenterMarkStyle) -> None: ...
    @property
    def SuppressExtension1(self) -> bool: ...
    @SuppressExtension1.setter
    def SuppressExtension1(self, value: bool) -> None: ...
    @property
    def SuppressExtension2(self) -> bool: ...
    @SuppressExtension2.setter
    def SuppressExtension2(self, value: bool) -> None: ...
    @property
    def ArrowheadType1(self) -> ArrowType: ...
    @ArrowheadType1.setter
    def ArrowheadType1(self, value: ArrowType) -> None: ...
    @property
    def ArrowheadType2(self) -> ArrowType: ...
    @ArrowheadType2.setter
    def ArrowheadType2(self, value: ArrowType) -> None: ...
    @property
    def ArrowSize(self) -> float: ...
    @ArrowSize.setter
    def ArrowSize(self, value: float) -> None: ...
    @property
    def ArrowBlockId1(self) -> Guid: ...
    @ArrowBlockId1.setter
    def ArrowBlockId1(self, value: Guid) -> None: ...
    @property
    def ArrowBlockId2(self) -> Guid: ...
    @ArrowBlockId2.setter
    def ArrowBlockId2(self, value: Guid) -> None: ...
    @property
    def LengthFactor(self) -> float: ...
    @LengthFactor.setter
    def LengthFactor(self, value: float) -> None: ...
    @property
    def LengthResolution(self) -> int: ...
    @LengthResolution.setter
    def LengthResolution(self, value: int) -> None: ...
    @property
    def LengthRoundoff(self) -> float: ...
    @LengthRoundoff.setter
    def LengthRoundoff(self, value: float) -> None: ...
    @property
    def Prefix(self) -> str: ...
    @Prefix.setter
    def Prefix(self, value: str) -> None: ...
    @property
    def Suffix(self) -> str: ...
    @Suffix.setter
    def Suffix(self, value: str) -> None: ...
    @property
    def ZeroSuppression(self) -> ZeroSuppression: ...
    @ZeroSuppression.setter
    def ZeroSuppression(self, value: ZeroSuppression) -> None: ...
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self, value: bool) -> None: ...
    @property
    def AltLengthFactor(self) -> float: ...
    @AltLengthFactor.setter
    def AltLengthFactor(self, value: float) -> None: ...
    @property
    def AltLengthResolution(self) -> int: ...
    @AltLengthResolution.setter
    def AltLengthResolution(self, value: int) -> None: ...
    @property
    def AltLengthRoundoff(self) -> float: ...
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self, value: float) -> None: ...
    @property
    def AltPrefix(self) -> str: ...


class OrdinateDimension(Dimension):
    def __init__(self): ...
    def Create(dimStyle: DimensionStyle, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float) -> OrdinateDimension: ...
    def AdjustFromPoints(self, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float) -> bool: ...
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d, Point3d]: ...
    @property
    def DefPoint(self) -> Point2d: ...
    @DefPoint.setter
    def DefPoint(self, value: Point2d) -> None: ...
    @property
    def LeaderPoint(self) -> Point2d: ...
    @LeaderPoint.setter
    def LeaderPoint(self, value: Point2d) -> None: ...
    @property
    def KinkPoint1(self) -> Point2d: ...
    @property
    def KinkPoint2(self) -> Point2d: ...
    @property
    def KinkOffset1(self) -> float: ...
    @KinkOffset1.setter
    def KinkOffset1(self, value: float) -> None: ...
    @property
    def KinkOffset2(self) -> float: ...
    @KinkOffset2.setter
    def KinkOffset2(self, value: float) -> None: ...
    def GetTextRectangle(self) -> Tuple[bool, Set(Point3d)]: ...
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Iterable[Line]]: ...
    def GetDistanceDisplayText(self, unitsystem: UnitSystem, style: DimensionStyle) -> str: ...


class SubDComponentLocation:
    Unset = 0
    ControlNet = 1
    Surface = 2


class SubDVertexTag:
    Unset = 0
    Smooth = 1
    Crease = 2
    Corner = 3
    Dart = 4


class SubDEdgeTag:
    Unset = 0
    Smooth = 1
    Crease = 2
    SmoothX = 4


class SubDVertexFacetType:
    Unset = 0
    Tri = 3
    Quad = 4
    Ngon = 5
    Mixed = 255


class SubDChainType:
    Unset = 0
    MixedTag = 1
    EqualEdgeTag = 2
    EqualEdgeAndVertexTag = 3


class SubDFriendlyKnotType:
    Unset = 0
    UnclampedUniform = 1
    ClampedUniform = 2
    ClampedPiecewiseUniform = 4
    Unfriendly = 127


class SubDPatchStyle:
    Unset = 0
    Automatic = 1
    SingleFace = 2
    TriangleFan = 3
    QuadOrTriangleFan = 4
    Triangulated = 5


class SubD(GeometryBase):
    def __init__(self): ...
    @property
    def Faces(self) -> SubDFaceList: ...
    @property
    def Vertices(self) -> SubDVertexList: ...
    @property
    def Edges(self) -> SubDEdgeList: ...
    @property
    def IsSolid(self) -> bool: ...
    def ToBrep(self) -> Brep: ...
    @overload
    def CreateFromMesh(mesh: Mesh) -> SubD: ...
    @overload
    def CreateFromMesh(mesh: Mesh, options: SubDCreationOptions) -> SubD: ...
    def ClearEvaluationCache(self) -> None: ...
    def UpdateAllTagsAndSectorCoefficients(self) -> UInt32: ...


class SubDCreationOptions:
    def __init__(self): ...
    @property
    def Smooth() -> SubDCreationOptions: ...
    @property
    def InteriorCreaseAtMeshCrease() -> SubDCreationOptions: ...
    @property
    def InteriorCreaseAtMeshEdge() -> SubDCreationOptions: ...
    @property
    def ConvexCornerAtMeshCorner() -> SubDCreationOptions: ...
    def Dispose(self) -> None: ...
    @property
    def InteriorCreaseTest(self) -> InteriorCreaseOption: ...
    @InteriorCreaseTest.setter
    def InteriorCreaseTest(self, value: InteriorCreaseOption) -> None: ...
    @property
    def ConvexCornerTest(self) -> ConvexCornerOption: ...
    @ConvexCornerTest.setter
    def ConvexCornerTest(self, value: ConvexCornerOption) -> None: ...
    @property
    def MinimumCreaseAngleRadians(self) -> float: ...
    @MinimumCreaseAngleRadians.setter
    def MinimumCreaseAngleRadians(self, value: float) -> None: ...
    @property
    def MaximumConvexCornerEdgeCount(self) -> UInt32: ...
    @MaximumConvexCornerEdgeCount.setter
    def MaximumConvexCornerEdgeCount(self, value: UInt32) -> None: ...
    @property
    def MaximumConvexCornerAngleRadians(self) -> float: ...
    @MaximumConvexCornerAngleRadians.setter
    def MaximumConvexCornerAngleRadians(self, value: float) -> None: ...
    @property
    def InterpolateMeshVertices(self) -> bool: ...
    @InterpolateMeshVertices.setter
    def InterpolateMeshVertices(self, value: bool) -> None: ...


class MeshPipeCapStyle:
    #None = 0
    Flat = 1
    Box = 2
    Dome = 3


class MeshExtruderParameterMode:
    CoverWalls = 0
    KeepAndStretch = 1


class MeshExtruderFaceDirectionMode:
    Keep = 0


class TextJustification:
    #None = 0
    Left = 1
    Center = 2
    Right = 4
    Bottom = 65536
    BottomLeft = 65537
    BottomCenter = 65538
    BottomRight = 65540
    Middle = 131072
    MiddleLeft = 131073
    MiddleCenter = 131074
    MiddleRight = 131076
    Top = 262144
    TopLeft = 262145
    TopCenter = 262146
    TopRight = 262148


class TextDot(GeometryBase):
    def __init__(self, text: str, location: Point3d): ...
    @property
    def Point(self) -> Point3d: ...
    @Point.setter
    def Point(self, value: Point3d) -> None: ...
    @property
    def Text(self) -> str: ...
    @Text.setter
    def Text(self, value: str) -> None: ...
    @property
    def SecondaryText(self) -> str: ...
    @SecondaryText.setter
    def SecondaryText(self, value: str) -> None: ...
    @property
    def FontHeight(self) -> int: ...
    @FontHeight.setter
    def FontHeight(self, value: int) -> None: ...
    @property
    def FontFace(self) -> str: ...
    @FontFace.setter
    def FontFace(self, value: str) -> None: ...


class AnnotationBase(GeometryBase):
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def DimensionStyleId(self) -> Guid: ...
    @DimensionStyleId.setter
    def DimensionStyleId(self, value: Guid) -> None: ...
    @property
    def HasPropertyOverrides(self) -> bool: ...
    def IsPropertyOverridden(self, field: Field) -> bool: ...
    def ClearPropertyOverrides(self) -> bool: ...
    def GetDimensionStyle(self, parentDimStyle: DimensionStyle) -> DimensionStyle: ...
    @property
    def DimensionStyle(self) -> DimensionStyle: ...
    def SetOverrideDimStyle(self, OverrideStyle: DimensionStyle) -> bool: ...
    @property
    def ParentDimensionStyle(self) -> DimensionStyle: ...
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self, value: DimensionStyle) -> None: ...
    @property
    def TextHeight(self) -> float: ...
    @TextHeight.setter
    def TextHeight(self, value: float) -> None: ...
    @property
    def MaskEnabled(self) -> bool: ...
    @MaskEnabled.setter
    def MaskEnabled(self, value: bool) -> None: ...
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self, value: bool) -> None: ...
    @property
    def MaskColorSource(self) -> MaskType: ...
    @MaskColorSource.setter
    def MaskColorSource(self, value: MaskType) -> None: ...
    @property
    def MaskColor(self) -> Color: ...
    @MaskColor.setter
    def MaskColor(self, value: Color) -> None: ...
    @property
    def MaskOffset(self) -> float: ...
    @MaskOffset.setter
    def MaskOffset(self, value: float) -> None: ...
    @property
    def DimensionScale(self) -> float: ...
    @DimensionScale.setter
    def DimensionScale(self, value: float) -> None: ...
    def GetDimensionScale(doc: RhinoDoc, dimstyle: DimensionStyle, vport: RhinoViewport) -> float: ...
    @property
    def DrawForward(self) -> bool: ...
    @DrawForward.setter
    def DrawForward(self, value: bool) -> None: ...
    @property
    def Font(self) -> Font: ...
    @Font.setter
    def Font(self, value: Font) -> None: ...
    @property
    def FontIndex(self) -> int: ...
    @FontIndex.setter
    def FontIndex(self, value: int) -> None: ...
    @property
    def DimensionLengthDisplay(self) -> LengthDisplay: ...
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @property
    def AlternateDimensionLengthDisplay(self) -> LengthDisplay: ...
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self, value: LengthDisplay) -> None: ...
    @property
    def Plane(self) -> Plane: ...
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @property
    def TextFormula(self) -> str: ...
    @TextFormula.setter
    def TextFormula(self, value: str) -> None: ...
    @property
    def RichText(self) -> str: ...
    @RichText.setter
    def RichText(self, value: str) -> None: ...
    @property
    def Text(self) -> str: ...
    @Text.setter
    def Text(self, value: str) -> None: ...
    @property
    def PlainText(self) -> str: ...
    @PlainText.setter
    def PlainText(self, value: str) -> None: ...
    def PlainTextToRtf(str: str) -> str: ...
    def SetRichText(self, rtfText: str, dimstyle: DimensionStyle) -> None: ...
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    def FormatRtfString(rtf_in: str, clear_bold: bool, set_bold: bool, clear_italic: bool, set_italic: bool, clear_underline: bool, set_underline: bool, clear_facename: bool, set_facename: bool, facename: str) -> str: ...
    def FirstCharProperties(rtf_str: str, bold: bool, italic: bool, underline: bool, facename: str) -> Tuple[bool, bool, bool, bool, str]: ...
    @property
    def FirstCharFont(self) -> Font: ...
    @property
    def TextModelWidth(self) -> float: ...
    @property
    def FormatWidth(self) -> float: ...
    @FormatWidth.setter
    def FormatWidth(self, value: float) -> None: ...
    @property
    def TextIsWrapped(self) -> bool: ...
    @TextIsWrapped.setter
    def TextIsWrapped(self, value: bool) -> None: ...
    def WrapText(self) -> None: ...
    @property
    def TextRotationRadians(self) -> float: ...
    @TextRotationRadians.setter
    def TextRotationRadians(self, value: float) -> None: ...
    @property
    def TextRotationDegrees(self) -> float: ...
    @TextRotationDegrees.setter
    def TextRotationDegrees(self, value: float) -> None: ...
    def SetBold(self, set_on: bool) -> bool: ...
    def SetItalic(self, set_on: bool) -> bool: ...
    def SetUnderline(self, set_on: bool) -> bool: ...
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...


class InvalidDimensionStyleIdException:
    def __init__(self, msg: str): ...


class ArcCurve(Curve):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: ArcCurve): ...
    @overload
    def __init__(self, arc: Arc): ...
    @overload
    def __init__(self, arc: Arc, t0: float, t1: float): ...
    @overload
    def __init__(self, circle: Circle): ...
    @overload
    def __init__(self, circle: Circle, t0: float, t1: float): ...
    @property
    def Arc(self) -> Arc: ...
    @property
    def IsCompleteCircle(self) -> bool: ...
    @property
    def Radius(self) -> float: ...
    @property
    def AngleRadians(self) -> float: ...
    @property
    def AngleDegrees(self) -> float: ...


class Extrusion(Surface):
    def __init__(self): ...
    def Create(planarCurve: Curve, height: float, cap: bool) -> Extrusion: ...
    def CreateBoxExtrusion(box: Box, cap: bool) -> Extrusion: ...
    def CreateCylinderExtrusion(cylinder: Cylinder, capBottom: bool, capTop: bool) -> Extrusion: ...
    def CreatePipeExtrusion(cylinder: Cylinder, otherRadius: float, capTop: bool, capBottom: bool) -> Extrusion: ...
    @overload
    def ToBrep(self, splitKinkyFaces: bool) -> Brep: ...
    def SetPathAndUp(self, a: Point3d, b: Point3d, up: Vector3d) -> bool: ...
    @property
    def PathStart(self) -> Point3d: ...
    @property
    def PathEnd(self) -> Point3d: ...
    @property
    def PathTangent(self) -> Vector3d: ...
    @property
    def MiterPlaneNormalAtStart(self) -> Vector3d: ...
    @MiterPlaneNormalAtStart.setter
    def MiterPlaneNormalAtStart(self, value: Vector3d) -> None: ...
    @property
    def MiterPlaneNormalAtEnd(self) -> Vector3d: ...
    @MiterPlaneNormalAtEnd.setter
    def MiterPlaneNormalAtEnd(self, value: Vector3d) -> None: ...
    @property
    def IsMiteredAtStart(self) -> bool: ...
    @property
    def IsMiteredAtEnd(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsCappedAtBottom(self) -> bool: ...
    @property
    def IsCappedAtTop(self) -> bool: ...
    @property
    def CapCount(self) -> int: ...
    def GetProfileTransformation(self, s: float) -> Transform: ...
    def GetProfilePlane(self, s: float) -> Plane: ...
    def GetPathPlane(self, s: float) -> Plane: ...
    def SetOuterProfile(self, outerProfile: Curve, cap: bool) -> bool: ...
    def AddInnerProfile(self, innerProfile: Curve) -> bool: ...
    @property
    def ProfileCount(self) -> int: ...
    @overload
    def Profile3d(self, profileIndex: int, s: float) -> Curve: ...
    @overload
    def Profile3d(self, ci: ComponentIndex) -> Curve: ...
    def WallEdge(self, ci: ComponentIndex) -> Curve: ...
    def WallSurface(self, ci: ComponentIndex) -> Surface: ...
    def PathLineCurve(self) -> LineCurve: ...
    def ProfileIndex(self, profileParameter: float) -> int: ...
    def GetMesh(self, meshType: MeshType) -> Mesh: ...
    def GetWireframe(self) -> Set(Curve): ...


class BezierCurve:
    @overload
    def __init__(self, controlPoints: Iterable[Point2d]): ...
    @overload
    def __init__(self, controlPoints: Iterable[Point3d]): ...
    @overload
    def __init__(self, controlPoints: Iterable[Point4d]): ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def Dispose(self) -> None: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def CreateLoftedBezier(points: Iterable[Point3d]) -> BezierCurve: ...
    @overload
    def CreateLoftedBezier(points: Iterable[Point2d]) -> BezierCurve: ...
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    def PointAt(self, t: float) -> Point3d: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @property
    def IsRational(self) -> bool: ...
    @property
    def ControlVertexCount(self) -> int: ...
    def GetControlVertex2d(self, index: int) -> Point2d: ...
    def GetControlVertex3d(self, index: int) -> Point3d: ...
    def GetControlVertex4d(self, index: int) -> Point4d: ...
    def MakeRational(self) -> bool: ...
    def MakeNonRational(self) -> bool: ...
    def IncreaseDegree(self, desiredDegree: int) -> bool: ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    def Split(self, t: float) -> Tuple[bool, BezierCurve, BezierCurve]: ...
    def CreateCubicBeziers(sourceCurve: Curve, distanceTolerance: float, kinkTolerance: float) -> Set(BezierCurve): ...
    def CreateBeziers(sourceCurve: Curve) -> Set(BezierCurve): ...


class Box:
    @overload
    def __init__(self, bbox: BoundingBox): ...
    @overload
    def __init__(self, basePlane: Plane, xSize: Interval, ySize: Interval, zSize: Interval): ...
    @overload
    def __init__(self, basePlane: Plane, points: Iterable[Point3d]): ...
    @overload
    def __init__(self, basePlane: Plane, geometry: GeometryBase): ...
    @overload
    def __init__(self, basePlane: Plane, boundingbox: BoundingBox): ...
    @property
    def Empty() -> Box: ...
    @property
    def Unset() -> Box: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @property
    def X(self) -> Interval: ...
    @X.setter
    def X(self, value: Interval) -> None: ...
    @property
    def Y(self) -> Interval: ...
    @Y.setter
    def Y(self, value: Interval) -> None: ...
    @property
    def Z(self) -> Interval: ...
    @Z.setter
    def Z(self, value: Interval) -> None: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Area(self) -> float: ...
    @property
    def Volume(self) -> float: ...
    def PointAt(self, x: float, y: float, z: float) -> Point3d: ...
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    def FurthestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def Inflate(self, amount: float) -> None: ...
    @overload
    def Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None: ...
    @overload
    def Contains(self, point: Point3d) -> bool: ...
    @overload
    def Contains(self, point: Point3d, strict: bool) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox, strict: bool) -> bool: ...
    @overload
    def Contains(self, box: Box) -> bool: ...
    @overload
    def Contains(self, box: Box, strict: bool) -> bool: ...
    def Union(self, point: Point3d) -> None: ...
    def MakeValid(self) -> bool: ...
    def GetCorners(self) -> Set(Point3d): ...
    def Transform(self, xform: Transform) -> bool: ...
    def RepositionBasePlane(self, origin: Point3d) -> None: ...
    def ToBrep(self) -> Brep: ...
    def ToExtrusion(self) -> Extrusion: ...
    def EpsilonEquals(self, other: Box, epsilon: float) -> bool: ...


class PipeCapMode:
    #None = 0
    Flat = 1
    Round = 2


class LoftType:
    Normal = 0
    Loose = 1
    Tight = 2
    Straight = 3
    Developable = 4
    Uniform = 5


class ExtrudeCornerType:
    #None = 0
    Sharp = 1
    Round = 2
    Smooth = 3
    Chamfer = 4


class BlendType:
    Chamfer = 0
    Fillet = 1
    Blend = 2


class RailType:
    DistanceFromEdge = 0
    RollingBall = 1
    DistanceBetweenRails = 2


class SweepRebuild:
    #None = 0
    Rebuild = 1
    Refit = 2


class Brep(GeometryBase):
    def __init__(self): ...
    @property
    def Vertices(self) -> BrepVertexList: ...
    @property
    def Surfaces(self) -> BrepSurfaceList: ...
    @property
    def Edges(self) -> BrepEdgeList: ...
    @property
    def Trims(self) -> BrepTrimList: ...
    @property
    def Loops(self) -> BrepLoopList: ...
    @property
    def Faces(self) -> BrepFaceList: ...
    @property
    def Curves2D(self) -> BrepCurveList: ...
    @property
    def Curves3D(self) -> BrepCurveList: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def SolidOrientation(self) -> BrepSolidOrientation: ...
    @property
    def IsManifold(self) -> bool: ...
    @property
    def IsSurface(self) -> bool: ...
    def GetRegions(self) -> Set(BrepRegion): ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateBrep(self) -> Brep: ...
    def DuplicateSubBrep(self, faceIndices: Iterable[int]) -> Brep: ...
    @overload
    def DuplicateEdgeCurves(self) -> Set(Curve): ...
    @overload
    def DuplicateEdgeCurves(self, nakedOnly: bool) -> Set(Curve): ...
    def DuplicateNakedEdgeCurves(self, outer: bool, inner: bool) -> Set(Curve): ...
    def GetWireframe(self, density: int) -> Set(Curve): ...
    def DuplicateVertices(self) -> Set(Point3d): ...
    def Flip(self) -> None: ...
    def IsDuplicate(self, other: Brep, tolerance: float) -> bool: ...
    def IsValidTopology(self) -> Tuple[bool, str]: ...
    def IsValidGeometry(self) -> Tuple[bool, str]: ...
    def IsValidTolerancesAndFlags(self) -> Tuple[bool, str]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, Point3d, ComponentIndex, float, float, Vector3d]: ...
    def FindCoincidentBrepComponents(self, point: Point3d, tolerance: float) -> Tuple[Set(int), Set(int), Set(int)]: ...
    def IsPointInside(self, point: Point3d, tolerance: float, strictlyIn: bool) -> bool: ...
    def CapPlanarHoles(self, tolerance: float) -> Brep: ...
    def Join(self, otherBrep: Brep, tolerance: float, compact: bool) -> bool: ...
    def JoinNakedEdges(self, tolerance: float) -> int: ...
    @overload
    def MergeCoplanarFaces(self, tolerance: float) -> bool: ...
    @overload
    def MergeCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def Split(self, cutter: Brep, intersectionTolerance: float) -> Set(Brep): ...
    @overload
    def Split(self, cutter: Brep, intersectionTolerance: float) -> Tuple[Set(Brep), bool]: ...
    @overload
    def Split(self, cutters: Iterable[Brep], intersectionTolerance: float) -> Set(Brep): ...
    @overload
    def Split(self, cutters: Iterable[Curve], intersectionTolerance: float) -> Set(Brep): ...
    @overload
    def Split(self, cutters: Iterable[GeometryBase], normal: Vector3d, planView: bool, intersectionTolerance: float) -> Set(Brep): ...
    @overload
    def Trim(self, cutter: Brep, intersectionTolerance: float) -> Set(Brep): ...
    @overload
    def Trim(self, cutter: Plane, intersectionTolerance: float) -> Set(Brep): ...
    def UnjoinEdges(self, edgesToUnjoin: Iterable[int]) -> Set(Brep): ...
    def JoinEdges(self, edgeIndex0: int, edgeIndex1: int, joinTolerance: float, compact: bool) -> bool: ...
    def TransformComponent(self, components: Iterable[ComponentIndex], xform: Transform, tolerance: float, timeLimit: float, useMultipleThreads: bool) -> bool: ...
    @overload
    def GetArea(self) -> float: ...
    @overload
    def GetArea(self, relativeTolerance: float, absoluteTolerance: float) -> float: ...
    @overload
    def GetVolume(self) -> float: ...
    @overload
    def GetVolume(self, relativeTolerance: float, absoluteTolerance: float) -> float: ...
    def AddTrimCurve(self, curve: Curve) -> int: ...
    def AddEdgeCurve(self, curve: Curve) -> int: ...
    def AddSurface(self, surface: Surface) -> int: ...
    def Append(self, other: Brep) -> None: ...
    def SetVertices(self) -> None: ...
    def SetTrimIsoFlags(self) -> None: ...
    @overload
    def SetTolerancesBoxesAndFlags(self) -> None: ...
    @overload
    def SetTolerancesBoxesAndFlags(self, bLazy: bool, bSetVertexTolerances: bool, bSetEdgeTolerances: bool, bSetTrimTolerances: bool, bSetTrimIsoFlags: bool, bSetTrimTypeFlags: bool, bSetLoopTypeFlags: bool, bSetTrimBoxes: bool) -> None: ...
    def RebuildTrimsForV2(self, face: BrepFace, nurbsSurface: NurbsSurface) -> None: ...
    def MakeValidForV2(self) -> bool: ...
    def Compact(self) -> None: ...
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def RemoveHoles(self, tolerance: float) -> Brep: ...
    @overload
    def RemoveHoles(self, loops: Iterable[ComponentIndex], tolerance: float) -> Brep: ...
    def CullUnusedFaces(self) -> bool: ...
    def CullUnusedLoops(self) -> bool: ...
    def CullUnusedTrims(self) -> bool: ...
    def CullUnusedEdges(self) -> bool: ...
    def CullUnusedVertices(self) -> bool: ...
    def CullUnused3dCurves(self) -> bool: ...
    def CullUnused2dCurves(self) -> bool: ...
    def CullUnusedSurfaces(self) -> bool: ...
    def Standardize(self) -> None: ...
    def TryConvertBrep(geometry: GeometryBase) -> Brep: ...
    def ChangeSeam(face: BrepFace, direction: int, parameter: float, tolerance: float) -> Brep: ...
    def CopyTrimCurves(trimSource: BrepFace, surfaceSource: Surface, tolerance: float) -> Brep: ...
    def CreateBaseballSphere(center: Point3d, radius: float, tolerance: float) -> Brep: ...
    @overload
    def CreateDevelopableLoft(crv0: Curve, crv1: Curve, reverse0: bool, reverse1: bool, density: int) -> Set(Brep): ...
    @overload
    def CreateDevelopableLoft(rail0: NurbsCurve, rail1: NurbsCurve, fixedRulings: Iterable[Point2d]) -> Set(Brep): ...
    def CreateFromMesh(mesh: Mesh, trimmedTriangles: bool) -> Brep: ...
    @overload
    def CreateFromBox(box: BoundingBox) -> Brep: ...
    @overload
    def CreateFromBox(box: Box) -> Brep: ...
    @overload
    def CreateFromBox(corners: Iterable[Point3d]) -> Brep: ...
    def CreateFromCylinder(cylinder: Cylinder, capBottom: bool, capTop: bool) -> Brep: ...
    def CreateFromSphere(sphere: Sphere) -> Brep: ...
    def CreateQuadSphere(sphere: Sphere) -> Brep: ...
    def CreateFromCone(cone: Cone, capBottom: bool) -> Brep: ...
    def CreateFromRevSurface(surface: RevSurface, capStart: bool, capEnd: bool) -> Brep: ...
    def CreateFromSurface(surface: Surface) -> Brep: ...
    @overload
    def CreateTrimmedPlane(plane: Plane, curve: Curve) -> Brep: ...
    @overload
    def CreateTrimmedPlane(plane: Plane, curves: Iterable[Curve]) -> Brep: ...
    @overload
    def CreatePlanarBreps(inputLoops: Iterable[Curve]) -> Set(Brep): ...
    @overload
    def CreatePlanarBreps(inputLoops: Iterable[Curve], tolerance: float) -> Set(Brep): ...
    @overload
    def CreatePlanarBreps(inputLoop: Curve) -> Set(Brep): ...
    @overload
    def CreatePlanarBreps(inputLoop: Curve, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateTrimmedSurface(trimSource: BrepFace, surfaceSource: Surface) -> Brep: ...
    @overload
    def CreateTrimmedSurface(trimSource: BrepFace, surfaceSource: Surface, tolerance: float) -> Brep: ...
    @overload
    def CreateFromCornerPoints(corner1: Point3d, corner2: Point3d, corner3: Point3d, tolerance: float) -> Brep: ...
    @overload
    def CreateFromCornerPoints(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d, tolerance: float) -> Brep: ...
    def CreateEdgeSurface(curves: Iterable[Curve]) -> Brep: ...
    @overload
    def CreatePlanarBreps(inputLoops: CurveList) -> Set(Brep): ...
    @overload
    def CreatePlanarBreps(inputLoops: CurveList, tolerance: float) -> Set(Brep): ...
    def CreateFromOffsetFace(face: BrepFace, offsetDistance: float, offsetTolerance: float, bothSides: bool, createSolid: bool) -> Brep: ...
    def CreateSolid(breps: Iterable[Brep], tolerance: float) -> Set(Brep): ...
    @overload
    def MergeSurfaces(surface0: Surface, surface1: Surface, tolerance: float, angleToleranceRadians: float) -> Brep: ...
    @overload
    def MergeSurfaces(brep0: Brep, brep1: Brep, tolerance: float, angleToleranceRadians: float) -> Brep: ...
    @overload
    def MergeSurfaces(brep0: Brep, brep1: Brep, tolerance: float, angleToleranceRadians: float, point0: Point2d, point1: Point2d, roundness: float, smooth: bool) -> Brep: ...
    @overload
    def CreatePatch(geometry: Iterable[GeometryBase], startingSurface: Surface, tolerance: float) -> Brep: ...
    @overload
    def CreatePatch(geometry: Iterable[GeometryBase], uSpans: int, vSpans: int, tolerance: float) -> Brep: ...
    @overload
    def CreatePatch(geometry: Iterable[GeometryBase], startingSurface: Surface, uSpans: int, vSpans: int, trim: bool, tangency: bool, pointSpacing: float, flexibility: float, surfacePull: float, fixEdges: Set(bool), tolerance: float) -> Brep: ...
    @overload
    def CreatePipe(rail: Curve, radius: float, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> Set(Brep): ...
    @overload
    def CreatePipe(rail: Curve, railRadiiParameters: Iterable[float], radii: Iterable[float], localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> Set(Brep): ...
    @overload
    def CreateFromSweep(rail: Curve, shape: Curve, closed: bool, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateFromSweep(rail: Curve, shapes: Iterable[Curve], closed: bool, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateFromSweepSegmented(rail: Curve, shape: Curve, closed: bool, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateFromSweepSegmented(rail: Curve, shapes: Iterable[Curve], closed: bool, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateFromSweep(rail1: Curve, rail2: Curve, shape: Curve, closed: bool, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Iterable[Curve], closed: bool, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Iterable[Curve], start: Point3d, end: Point3d, closed: bool, tolerance: float, rebuild: SweepRebuild, rebuildPointCount: int, refitTolerance: float, preserveHeight: bool) -> Set(Brep): ...
    def CreateFromSweepInParts(rail1: Curve, rail2: Curve, shapes: Iterable[Curve], rail_params: Iterable[Point2d], closed: bool, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateFromTaperedExtrude(curveToExtrude: Curve, distance: float, direction: Vector3d, basePoint: Point3d, draftAngleRadians: float, cornerType: ExtrudeCornerType, tolerance: float, angleToleranceRadians: float) -> Set(Brep): ...
    @overload
    def CreateFromTaperedExtrude(curveToExtrude: Curve, distance: float, direction: Vector3d, basePoint: Point3d, draftAngleRadians: float, cornerType: ExtrudeCornerType) -> Set(Brep): ...
    def CreateFromTaperedExtrudeWithRef(curve: Curve, direction: Vector3d, distance: float, draftAngle: float, plane: Plane, tolerance: float) -> Set(Brep): ...
    def CreateBlendSurface(face0: BrepFace, edge0: BrepEdge, domain0: Interval, rev0: bool, continuity0: BlendContinuity, face1: BrepFace, edge1: BrepEdge, domain1: Interval, rev1: bool, continuity1: BlendContinuity) -> Set(Brep): ...
    def CreateBlendShape(face0: BrepFace, edge0: BrepEdge, t0: float, rev0: bool, continuity0: BlendContinuity, face1: BrepFace, edge1: BrepEdge, t1: float, rev1: bool, continuity1: BlendContinuity) -> Curve: ...
    @overload
    def CreateFilletSurface(face0: BrepFace, uv0: Point2d, face1: BrepFace, uv1: Point2d, radius: float, extend: bool, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateFilletSurface(face0: BrepFace, uv0: Point2d, face1: BrepFace, uv1: Point2d, radius: float, trim: bool, extend: bool, tolerance: float) -> Tuple[Set(Brep), Set(Brep), Set(Brep)]: ...
    @overload
    def CreateChamferSurface(face0: BrepFace, uv0: Point2d, radius0: float, face1: BrepFace, uv1: Point2d, radius1: float, extend: bool, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateChamferSurface(face0: BrepFace, uv0: Point2d, radius0: float, face1: BrepFace, uv1: Point2d, radius1: float, trim: bool, extend: bool, tolerance: float) -> Tuple[Set(Brep), Set(Brep), Set(Brep)]: ...
    def CreateFilletEdges(brep: Brep, edgeIndices: Iterable[int], startRadii: Iterable[float], endRadii: Iterable[float], blendType: BlendType, railType: RailType, tolerance: float) -> Set(Brep): ...
    def CreateOffsetBrep(brep: Brep, distance: float, solid: bool, extend: bool, tolerance: float) -> Tuple[Set(Brep), Set(Brep), Set(Brep)]: ...
    def CreateFromJoinedEdges(brep0: Brep, edgeIndex0: int, brep1: Brep, edgeIndex1: int, joinTolerance: float) -> Brep: ...
    def CreateFromLoft(curves: Iterable[Curve], start: Point3d, end: Point3d, loftType: LoftType, closed: bool) -> Set(Brep): ...
    def CreateFromLoftRebuild(curves: Iterable[Curve], start: Point3d, end: Point3d, loftType: LoftType, closed: bool, rebuildPointCount: int) -> Set(Brep): ...
    def CreateFromLoftRefit(curves: Iterable[Curve], start: Point3d, end: Point3d, loftType: LoftType, closed: bool, refitTolerance: float) -> Set(Brep): ...
    @overload
    def CreateBooleanUnion(breps: Iterable[Brep], tolerance: float) -> Set(Brep): ...
    @overload
    def CreateBooleanUnion(breps: Iterable[Brep], tolerance: float, manifoldOnly: bool) -> Set(Brep): ...
    @overload
    def CreateBooleanIntersection(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float) -> Set(Brep): ...
    @overload
    def CreateBooleanIntersection(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float, manifoldOnly: bool) -> Set(Brep): ...
    @overload
    def CreateBooleanIntersection(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateBooleanIntersection(firstBrep: Brep, secondBrep: Brep, tolerance: float, manifoldOnly: bool) -> Set(Brep): ...
    @overload
    def CreateBooleanDifference(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float) -> Set(Brep): ...
    @overload
    def CreateBooleanDifference(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float, manifoldOnly: bool) -> Set(Brep): ...
    @overload
    def CreateBooleanDifference(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateBooleanDifference(firstBrep: Brep, secondBrep: Brep, tolerance: float, manifoldOnly: bool) -> Set(Brep): ...
    @overload
    def CreateBooleanSplit(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> Set(Brep): ...
    @overload
    def CreateBooleanSplit(firstSet: Iterable[Brep], secondSet: Iterable[Brep], tolerance: float) -> Set(Brep): ...
    def CreateShell(brep: Brep, facesToRemove: Iterable[int], distance: float, tolerance: float) -> Set(Brep): ...
    def JoinBreps(brepsToJoin: Iterable[Brep], tolerance: float) -> Set(Brep): ...
    def MergeBreps(brepsToMerge: Iterable[Brep], tolerance: float) -> Brep: ...
    @overload
    def CreateContourCurves(brepToContour: Brep, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Set(Curve): ...
    @overload
    def CreateContourCurves(brepToContour: Brep, sectionPlane: Plane) -> Set(Curve): ...
    def CreateCurvatureAnalysisMesh(brep: Brep, state: CurvatureAnalysisSettingsState) -> Set(Mesh): ...


class PointFaceRelation:
    Exterior = 0
    Interior = 1
    Boundary = 2


class BrepSolidOrientation:
    #None = 0
    Outward = 1
    Unknown = 2
    Inward = -1


class EdgeAdjacency:
    #None = 0
    Naked = 1
    Interior = 2
    NonManifold = 3


class Concavity:
    Tangent = 0
    Convex = 1
    Concave = 2
    #None = -1


class BrepVertex(Point):
    @property
    def Brep(self) -> Brep: ...
    @property
    def VertexIndex(self) -> int: ...
    def EdgeIndices(self) -> Set(int): ...


class BrepEdge(CurveProxy):
    @property
    def Tolerance(self) -> float: ...
    @Tolerance.setter
    def Tolerance(self, value: float) -> None: ...
    @property
    def TrimCount(self) -> int: ...
    @property
    def Valence(self) -> EdgeAdjacency: ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def EdgeIndex(self) -> int: ...
    def ConcavityAt(self, t: float, tolerance: float) -> Concavity: ...
    def IsSmoothManifoldEdge(self, angleToleranceRadians: float) -> bool: ...
    def AdjacentFaces(self) -> Set(int): ...
    def TrimIndices(self) -> Set(int): ...
    def GetEdgeParameter(self, trimIndex: int, trimParameter: float) -> Tuple[bool, float]: ...
    @property
    def EdgeCurveIndex(self) -> int: ...
    @property
    def EdgeCurve(self) -> Curve: ...
    @overload
    def SetEdgeCurve(self, curve3dIndex: int) -> bool: ...
    @overload
    def SetEdgeCurve(self, curve3dIndex: int, subDomain: Interval) -> bool: ...
    @property
    def StartVertex(self) -> BrepVertex: ...
    @property
    def EndVertex(self) -> BrepVertex: ...


class BrepTrimType:
    Unknown = 0
    Boundary = 1
    Mated = 2
    Seam = 3
    Singular = 4
    CurveOnSurface = 5
    PointOnSurface = 6
    Slit = 7


class BrepTrim(CurveProxy):
    @property
    def Brep(self) -> Brep: ...
    @property
    def Loop(self) -> BrepLoop: ...
    @property
    def Face(self) -> BrepFace: ...
    @property
    def Edge(self) -> BrepEdge: ...
    @property
    def TrimCurveIndex(self) -> int: ...
    @property
    def TrimCurve(self) -> Curve: ...
    @property
    def TrimIndex(self) -> int: ...
    @property
    def TrimType(self) -> BrepTrimType: ...
    @TrimType.setter
    def TrimType(self, value: BrepTrimType) -> None: ...
    @property
    def IsoStatus(self) -> IsoStatus: ...
    @IsoStatus.setter
    def IsoStatus(self, value: IsoStatus) -> None: ...
    def IsReversed(self) -> bool: ...
    def GetTrimParameter(self, edgeParameter: float) -> Tuple[bool, float]: ...
    def GetTolerances(self) -> Tuple[float, float]: ...
    def SetTolerances(self, toleranceU: float, toleranceV: float) -> None: ...
    @overload
    def SetTrimCurve(self, curve2dIndex: int) -> bool: ...
    @property
    def StartVertex(self) -> BrepVertex: ...
    @property
    def EndVertex(self) -> BrepVertex: ...
    @overload
    def SetTrimCurve(self, curve2dIndex: int, subDomain: Interval) -> bool: ...


class BrepLoopType:
    Unknown = 0
    Outer = 1
    Inner = 2
    Slit = 3
    CurveOnSurface = 4
    PointOnSurface = 5


class BrepLoop(GeometryBase):
    @property
    def Brep(self) -> Brep: ...
    @property
    def LoopIndex(self) -> int: ...
    @property
    def Face(self) -> BrepFace: ...
    @property
    def LoopType(self) -> BrepLoopType: ...
    @property
    def Trims(self) -> BrepTrimList: ...
    def To3dCurve(self) -> Curve: ...
    def To2dCurve(self) -> Curve: ...


class BrepFace(SurfaceProxy):
    @property
    def Brep(self) -> Brep: ...
    @property
    def OrientationIsReversed(self) -> bool: ...
    @OrientationIsReversed.setter
    def OrientationIsReversed(self, value: bool) -> None: ...
    @property
    def IsSurface(self) -> bool: ...
    @property
    def FaceIndex(self) -> int: ...
    @property
    def SurfaceIndex(self) -> int: ...
    @property
    def Loops(self) -> BrepLoopList: ...
    @property
    def OuterLoop(self) -> BrepLoop: ...
    def PullPointsToFace(self, points: Iterable[Point3d], tolerance: float) -> Set(Point3d): ...
    def DraftAnglePoint(self, testPoint: Point2d, testAngle: float, pullDirection: Vector3d, edge: bool) -> Tuple[bool, Point3d, float]: ...
    def RemoveHoles(self, tolerance: float) -> Brep: ...
    def CreateExtrusion(self, pathCurve: Curve, cap: bool) -> Brep: ...
    def ShrinkFace(self, disableSide: ShrinkDisableSide) -> bool: ...
    def ShrinkSurfaceToEdge(self) -> bool: ...
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    def DuplicateFace(self, duplicateMeshes: bool) -> Brep: ...
    def DuplicateSurface(self) -> Surface: ...
    def UnderlyingSurface(self) -> Surface: ...
    @overload
    def Split(self, curves: Iterable[Curve], tolerance: float) -> Brep: ...
    def IsPointOnFace(self, u: float, v: float) -> PointFaceRelation: ...
    def TrimAwareIsoIntervals(self, direction: int, constantParameter: float) -> Set(Interval): ...
    def TrimAwareIsoCurve(self, direction: int, constantParameter: float) -> Set(Curve): ...
    def GetMesh(self, meshType: MeshType) -> Mesh: ...
    def SetMesh(self, meshType: MeshType, mesh: Mesh) -> bool: ...
    def AdjacentEdges(self) -> Set(int): ...
    def AdjacentFaces(self) -> Set(int): ...
    def ChangeSurface(self, surfaceIndex: int) -> bool: ...
    def RebuildEdges(self, tolerance: float, rebuildSharedEdges: bool, rebuildVertices: bool) -> bool: ...


class BrepRegion(CommonObject):
    @property
    def Brep(self) -> Brep: ...
    @property
    def Index(self) -> int: ...
    @property
    def IsFinite(self) -> bool: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    def BoundaryBrep(self) -> Brep: ...
    def GetFaceSides(self) -> Set(BrepRegionFaceSide): ...


class BrepRegionFaceSide(CommonObject):
    @property
    def Brep(self) -> Brep: ...
    @property
    def Region(self) -> BrepRegion: ...
    @property
    def SurfaceNormalPointsIntoRegion(self) -> bool: ...
    @property
    def Face(self) -> BrepFace: ...


class ComponentStatus:
    @property
    def Clear() -> ComponentStatus: ...
    @property
    def Selected() -> ComponentStatus: ...
    @property
    def SelectedPersistent() -> ComponentStatus: ...
    @property
    def Highlighted() -> ComponentStatus: ...
    @property
    def Hidden() -> ComponentStatus: ...
    @property
    def Locked() -> ComponentStatus: ...
    @property
    def Damaged() -> ComponentStatus: ...
    @property
    def AllSet() -> ComponentStatus: ...
    @property
    def IsClear(self) -> bool: ...
    @property
    def IsDamaged(self) -> bool: ...
    @property
    def IsHighlighted(self) -> bool: ...
    @property
    def IsHidden(self) -> bool: ...
    @property
    def IsLocked(self) -> bool: ...
    @property
    def IsSelected(self) -> bool: ...
    @property
    def IsSelectedPersistent(self) -> bool: ...
    def WithStates(self, additionalStatus: ComponentStatus) -> ComponentStatus: ...
    def HasSomeEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    def HasAllEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    def HasNoEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    def op_Addition(a: ComponentStatus, b: ComponentStatus) -> ComponentStatus: ...
    def op_Equality(a: ComponentStatus, b: ComponentStatus) -> bool: ...
    def op_Inequality(a: ComponentStatus, b: ComponentStatus) -> bool: ...
    def ToString(self) -> str: ...
    @overload
    def Equals(self, other: ComponentStatus) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    def GetHashCode(self) -> int: ...


class CurveProxy(Curve):
    @property
    def ProxyCurveIsReversed(self) -> bool: ...


class DetailView(GeometryBase):
    @property
    def IsParallelProjection(self) -> bool: ...
    @IsParallelProjection.setter
    def IsParallelProjection(self, value: bool) -> None: ...
    @property
    def IsPerspectiveProjection(self) -> bool: ...
    @IsPerspectiveProjection.setter
    def IsPerspectiveProjection(self, value: bool) -> None: ...
    @property
    def IsProjectionLocked(self) -> bool: ...
    @IsProjectionLocked.setter
    def IsProjectionLocked(self, value: bool) -> None: ...
    @property
    def PageToModelRatio(self) -> float: ...
    def SetScale(self, modelLength: float, modelUnits: UnitSystem, pageLength: float, pageUnits: UnitSystem) -> bool: ...


class LinearDimension(Dimension):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, dimensionPlane: Plane, extensionLine1End: Point2d, extensionLine2End: Point2d, pointOnDimensionLine: Point2d): ...
    def FromPoints(extensionLine1End: Point3d, extensionLine2End: Point3d, pointOnDimensionLine: Point3d) -> LinearDimension: ...
    @property
    def DistanceBetweenArrowTips(self) -> float: ...
    def SetLocations(self, extensionLine1End: Point2d, extensionLine2End: Point2d, pointOnDimensionLine: Point2d) -> None: ...
    @property
    def Aligned(self) -> bool: ...
    @Aligned.setter
    def Aligned(self, value: bool) -> None: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @AnnotationType.setter
    def AnnotationType(self, value: AnnotationType) -> None: ...
    def Create(dimtype: AnnotationType, dimStyle: DimensionStyle, plane: Plane, horizontal: Vector3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d, rotationInPlane: float) -> LinearDimension: ...
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d]: ...
    @property
    def ExtensionLine1End(self) -> Point2d: ...
    @ExtensionLine1End.setter
    def ExtensionLine1End(self, value: Point2d) -> None: ...
    @property
    def ExtensionLine2End(self) -> Point2d: ...
    @ExtensionLine2End.setter
    def ExtensionLine2End(self, value: Point2d) -> None: ...
    @property
    def Arrowhead1End(self) -> Point2d: ...
    @property
    def Arrowhead2End(self) -> Point2d: ...
    @property
    def DimensionLinePoint(self) -> Point2d: ...
    @DimensionLinePoint.setter
    def DimensionLinePoint(self, value: Point2d) -> None: ...
    def GetTextRectangle(self) -> Tuple[bool, Set(Point3d)]: ...
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Iterable[Line]]: ...
    def GetDistanceDisplayText(self, unitsystem: UnitSystem, style: DimensionStyle) -> str: ...


class AngularDimension(Dimension):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, arc: Arc, offset: float): ...
    @overload
    def Create(dimStyle: DimensionStyle, plane: Plane, horizontal: Vector3d, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d) -> AngularDimension: ...
    @overload
    def AdjustFromPoints(self, plane: Plane, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d) -> bool: ...
    @overload
    def Create(styleId: Guid, plane: Plane, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d) -> AngularDimension: ...
    @overload
    def AdjustFromPoints(self, plane: Plane, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d) -> bool: ...
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d]: ...
    @property
    def CenterPoint(self) -> Point2d: ...
    @CenterPoint.setter
    def CenterPoint(self, value: Point2d) -> None: ...
    @property
    def DefPoint1(self) -> Point2d: ...
    @DefPoint1.setter
    def DefPoint1(self, value: Point2d) -> None: ...
    @property
    def DefPoint2(self) -> Point2d: ...
    @DefPoint2.setter
    def DefPoint2(self, value: Point2d) -> None: ...
    @property
    def DimlinePoint(self) -> Point2d: ...
    @DimlinePoint.setter
    def DimlinePoint(self, value: Point2d) -> None: ...
    @property
    def ArrowPoint1(self) -> Point2d: ...
    @property
    def ArrowPoint2(self) -> Point2d: ...
    def GetTextRectangle(self) -> Tuple[bool, Set(Point3d)]: ...
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Set(Line), Set(Arc)]: ...
    def GetAngleDisplayText(self, style: DimensionStyle) -> str: ...
    @property
    def AngleFormat(self) -> AngleDisplayFormat: ...
    @AngleFormat.setter
    def AngleFormat(self, value: AngleDisplayFormat) -> None: ...
    @property
    def AngleResolution(self) -> int: ...
    @AngleResolution.setter
    def AngleResolution(self, value: int) -> None: ...
    @property
    def AngleRoundoff(self) -> float: ...
    @AngleRoundoff.setter
    def AngleRoundoff(self, value: float) -> None: ...
    @property
    def AngleZeroSuppression(self) -> ZeroSuppression: ...
    @AngleZeroSuppression.setter
    def AngleZeroSuppression(self, value: ZeroSuppression) -> None: ...


class RadialDimension(Dimension):
    def __init__(self): ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @AnnotationType.setter
    def AnnotationType(self, value: AnnotationType) -> None: ...
    @property
    def IsDiameterDimension(self) -> bool: ...
    def Create(dimStyle: DimensionStyle, dimtype: AnnotationType, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d) -> RadialDimension: ...
    def AdjustFromPoints(self, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d, rotationInPlane: float) -> bool: ...
    def Get3dPoints(self) -> Tuple[bool, Point3d, Point3d, Point3d, Point3d]: ...
    @property
    def CenterPoint(self) -> Point2d: ...
    @CenterPoint.setter
    def CenterPoint(self, value: Point2d) -> None: ...
    @property
    def RadiusPoint(self) -> Point2d: ...
    @RadiusPoint.setter
    def RadiusPoint(self, value: Point2d) -> None: ...
    @property
    def DimlinePoint(self) -> Point2d: ...
    @DimlinePoint.setter
    def DimlinePoint(self, value: Point2d) -> None: ...
    @property
    def KneePoint(self) -> Point2d: ...
    def GetTextRectangle(self) -> Tuple[bool, Set(Point3d)]: ...
    def GetDisplayLines(self, style: DimensionStyle, scale: float) -> Tuple[bool, Iterable[Line]]: ...
    def GetDistanceDisplayText(self, unitsystem: UnitSystem, style: DimensionStyle) -> str: ...
    @property
    def LeaderTextHorizontalAlignment(self) -> TextHorizontalAlignment: ...
    @LeaderTextHorizontalAlignment.setter
    def LeaderTextHorizontalAlignment(self, value: TextHorizontalAlignment) -> None: ...
    @property
    def LeaderArrowType(self) -> ArrowType: ...
    @LeaderArrowType.setter
    def LeaderArrowType(self, value: ArrowType) -> None: ...
    @property
    def LeaderArrowSize(self) -> float: ...
    @LeaderArrowSize.setter
    def LeaderArrowSize(self, value: float) -> None: ...
    @property
    def LeaderArrowBlockId(self) -> Guid: ...
    @LeaderArrowBlockId.setter
    def LeaderArrowBlockId(self, value: Guid) -> None: ...
    @property
    def LeaderCurveStyle(self) -> LeaderCurveStyle: ...
    @LeaderCurveStyle.setter
    def LeaderCurveStyle(self, value: LeaderCurveStyle) -> None: ...
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @TextOrientation.setter
    def TextOrientation(self, value: TextOrientation) -> None: ...
    @property
    def TextLocation(self) -> TextLocation: ...
    @TextLocation.setter
    def TextLocation(self, value: TextLocation) -> None: ...
    @property
    def TextAngleType(self) -> LeaderContentAngleStyle: ...
    @TextAngleType.setter
    def TextAngleType(self, value: LeaderContentAngleStyle) -> None: ...


class Centermark(Dimension):
    def __init__(self): ...
    def Create(dimStyle: DimensionStyle, plane: Plane, centerpoint: Point3d, radius: float) -> Centermark: ...


class Hatch(GeometryBase):
    @overload
    def Create(curves: Iterable[Curve], hatchPatternIndex: int, rotationRadians: float, scale: float) -> Set(Hatch): ...
    @overload
    def Create(curves: Iterable[Curve], hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> Set(Hatch): ...
    @overload
    def Create(curve: Curve, hatchPatternIndex: int, rotationRadians: float, scale: float) -> Set(Hatch): ...
    @overload
    def Create(curve: Curve, hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> Set(Hatch): ...
    def CreateDisplayGeometry(self, pattern: HatchPattern, patternScale: float) -> Tuple[Set(Curve), Set(Line), Brep]: ...
    def Explode(self) -> Set(GeometryBase): ...
    def Get3dCurves(self, outer: bool) -> Set(Curve): ...
    @property
    def PatternIndex(self) -> int: ...
    @PatternIndex.setter
    def PatternIndex(self, value: int) -> None: ...
    @property
    def PatternRotation(self) -> float: ...
    @PatternRotation.setter
    def PatternRotation(self, value: float) -> None: ...
    @property
    def BasePoint(self) -> Point3d: ...
    @BasePoint.setter
    def BasePoint(self, value: Point3d) -> None: ...
    @property
    def Plane(self) -> Plane: ...
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @property
    def PatternScale(self) -> float: ...
    @PatternScale.setter
    def PatternScale(self, value: float) -> None: ...
    def ScalePattern(self, xform: Transform) -> None: ...
    def GetGradientFill(self) -> ColorGradient: ...
    def SetGradientFill(self, fill: ColorGradient) -> None: ...


class HiddenLineDrawingParameters:
    def __init__(self): ...
    @property
    def AbsoluteTolerance(self) -> float: ...
    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, value: float) -> None: ...
    @overload
    def SetViewport(self, viewport: ViewportInfo) -> None: ...
    @overload
    def SetViewport(self, viewport: RhinoViewport) -> None: ...
    @property
    def Flatten(self) -> bool: ...
    @Flatten.setter
    def Flatten(self, value: bool) -> None: ...
    def AddClippingPlane(self, plane: Plane) -> None: ...
    @property
    def IncludeTangentEdges(self) -> bool: ...
    @IncludeTangentEdges.setter
    def IncludeTangentEdges(self, value: bool) -> None: ...
    @property
    def IncludeTangentSeams(self) -> bool: ...
    @IncludeTangentSeams.setter
    def IncludeTangentSeams(self, value: bool) -> None: ...
    @property
    def IncludeHiddenCurves(self) -> bool: ...
    @IncludeHiddenCurves.setter
    def IncludeHiddenCurves(self, value: bool) -> None: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, tag: Object) -> bool: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, xform: Transform, tag: Object) -> bool: ...


class HiddenLineDrawing:
    @overload
    def Compute(parameters: HiddenLineDrawingParameters, multipleThreads: bool) -> HiddenLineDrawing: ...
    @overload
    def Compute(parameters: HiddenLineDrawingParameters, multipleThreads: bool, progress: IProgress, cancelToken: CancellationToken) -> HiddenLineDrawing: ...
    def Dispose(self) -> None: ...
    @property
    def Segments(self) -> Iterable[HiddenLineDrawingSegment]: ...
    @property
    def Points(self) -> Iterable[HiddenLineDrawingPoint]: ...
    @property
    def Viewport(self) -> ViewportInfo: ...
    def BoundingBox(self, includeHidden: bool) -> BoundingBox: ...
    @property
    def WorldToHiddenLine(self) -> Transform: ...


class HiddenLineDrawingObject:
    @property
    def Geometry(self) -> GeometryBase: ...
    @property
    def Transform(self) -> Transform: ...
    @property
    def Tag(self) -> Object: ...


class HiddenLineDrawingPoint:
    @property
    def SourceObject(self) -> HiddenLineDrawingObject: ...
    @property
    def SourceObjectComponentIndex(self) -> ComponentIndex: ...
    @property
    def ClippingPlaneIndex(self) -> int: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def Index(self) -> int: ...
    @property
    def PointVisibility(self) -> Visibility: ...


class HiddenLineDrawingObjectCurve:
    @property
    def IsValid(self) -> bool: ...
    @property
    def SourceObject(self) -> HiddenLineDrawingObject: ...
    @property
    def SourceObjectComponentIndex(self) -> ComponentIndex: ...
    @property
    def ClippingPlaneIndex(self) -> int: ...
    @property
    def Index(self) -> int: ...
    @property
    def SilhouetteType(self) -> SilhouetteType: ...
    @property
    def OriginalDomainStart(self) -> float: ...
    @property
    def Parameters(self) -> Set(float): ...
    @property
    def Segments(self) -> Set(HiddenLineDrawingSegment): ...
    @property
    def IsProjecting(self) -> bool: ...
    @overload
    def Curve(self, t: float) -> HiddenLineDrawingSegment: ...
    @overload
    def Curve(self, t: float, side: int) -> HiddenLineDrawingSegment: ...


class HiddenLineDrawingSegment:
    @property
    def Index(self) -> int: ...
    @property
    def CurveGeometry(self) -> Curve: ...
    @property
    def ParentCurve(self) -> HiddenLineDrawingObjectCurve: ...
    @property
    def SegmentVisibility(self) -> Visibility: ...
    @property
    def IsSceneSilhouette(self) -> bool: ...
    @property
    def CurveSideFills(self) -> Set(SideFill): ...


class InstanceDefinitionGeometry(ModelComponent):
    def __init__(self): ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> None: ...
    @property
    def ComponentType(self) -> ModelComponentType: ...
    def GetObjectIds(self) -> Set(Guid): ...


class InstanceReferenceGeometry(GeometryBase):
    def __init__(self, instanceDefinitionId: Guid, transform: Transform): ...
    @property
    def ParentIdefId(self) -> Guid: ...
    @property
    def Xform(self) -> Transform: ...


class Arrowhead:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, arrowType: ArrowType, blockId: Guid): ...
    @property
    def BlockId(self) -> Guid: ...
    @property
    def ArrowType(self) -> ArrowType: ...


class Leader(AnnotationBase):
    def __init__(self): ...
    def Create(text: str, plane: Plane, dimstyle: DimensionStyle, points: Set(Point3d)) -> Leader: ...
    def CreateWithRichText(richText: str, plane: Plane, dimstyle: DimensionStyle, points: Set(Point3d)) -> Leader: ...
    @property
    def Curve(self) -> NurbsCurve: ...
    @property
    def Points2D(self) -> Set(Point2d): ...
    @Points2D.setter
    def Points2D(self, value: Set(Point2d)) -> None: ...
    @property
    def Points3D(self) -> Set(Point3d): ...
    @Points3D.setter
    def Points3D(self, value: Set(Point3d)) -> None: ...
    @property
    def LeaderTextHorizontalAlignment(self) -> TextHorizontalAlignment: ...
    @LeaderTextHorizontalAlignment.setter
    def LeaderTextHorizontalAlignment(self, value: TextHorizontalAlignment) -> None: ...
    @property
    def LeaderTextVerticalAlignment(self) -> TextVerticalAlignment: ...
    @LeaderTextVerticalAlignment.setter
    def LeaderTextVerticalAlignment(self, value: TextVerticalAlignment) -> None: ...
    @property
    def LeaderArrowType(self) -> ArrowType: ...
    @LeaderArrowType.setter
    def LeaderArrowType(self, value: ArrowType) -> None: ...
    @property
    def LeaderArrowBlockId(self) -> Guid: ...
    @LeaderArrowBlockId.setter
    def LeaderArrowBlockId(self, value: Guid) -> None: ...
    @property
    def LeaderArrowSize(self) -> float: ...
    @LeaderArrowSize.setter
    def LeaderArrowSize(self, value: float) -> None: ...
    @property
    def LeaderCurveStyle(self) -> LeaderCurveStyle: ...
    @LeaderCurveStyle.setter
    def LeaderCurveStyle(self, value: LeaderCurveStyle) -> None: ...
    @property
    def LeaderContentAngleStyle(self) -> LeaderContentAngleStyle: ...
    @LeaderContentAngleStyle.setter
    def LeaderContentAngleStyle(self, value: LeaderContentAngleStyle) -> None: ...
    @property
    def LeaderHasLanding(self) -> bool: ...
    @LeaderHasLanding.setter
    def LeaderHasLanding(self, value: bool) -> None: ...
    @property
    def LeaderLandingLength(self) -> float: ...
    @LeaderLandingLength.setter
    def LeaderLandingLength(self, value: float) -> None: ...


class Light(GeometryBase):
    def __init__(self): ...
    @overload
    def CreateSunLight(northAngleDegrees: float, azimuthDegrees: float, altitudeDegrees: float) -> Light: ...
    @overload
    def CreateSunLight(northAngleDegrees: float, when: DateTime, latitudeDegrees: float, longitudeDegrees: float) -> Light: ...
    @overload
    def CreateSunLight(sun: Sun) -> Light: ...
    @property
    def IsEnabled(self) -> bool: ...
    @IsEnabled.setter
    def IsEnabled(self, value: bool) -> None: ...
    @property
    def LightStyle(self) -> LightStyle: ...
    @LightStyle.setter
    def LightStyle(self, value: LightStyle) -> None: ...
    @property
    def IsPointLight(self) -> bool: ...
    @property
    def IsDirectionalLight(self) -> bool: ...
    @property
    def IsSpotLight(self) -> bool: ...
    @property
    def IsLinearLight(self) -> bool: ...
    @property
    def IsRectangularLight(self) -> bool: ...
    @property
    def IsSunLight(self) -> bool: ...
    @property
    def CoordinateSystem(self) -> CoordinateSystem: ...
    @property
    def Location(self) -> Point3d: ...
    @Location.setter
    def Location(self, value: Point3d) -> None: ...
    @property
    def Direction(self) -> Vector3d: ...
    @Direction.setter
    def Direction(self, value: Vector3d) -> None: ...
    @property
    def PerpendicularDirection(self) -> Vector3d: ...
    @property
    def Intensity(self) -> float: ...
    @Intensity.setter
    def Intensity(self, value: float) -> None: ...
    @property
    def PowerWatts(self) -> float: ...
    @PowerWatts.setter
    def PowerWatts(self, value: float) -> None: ...
    @property
    def PowerLumens(self) -> float: ...
    @PowerLumens.setter
    def PowerLumens(self, value: float) -> None: ...
    @property
    def PowerCandela(self) -> float: ...
    @PowerCandela.setter
    def PowerCandela(self, value: float) -> None: ...
    @property
    def Ambient(self) -> Color: ...
    @Ambient.setter
    def Ambient(self, value: Color) -> None: ...
    @property
    def Diffuse(self) -> Color: ...
    @Diffuse.setter
    def Diffuse(self, value: Color) -> None: ...
    @property
    def Specular(self) -> Color: ...
    @Specular.setter
    def Specular(self, value: Color) -> None: ...
    def SetAttenuation(self, a0: float, a1: float, a2: float) -> None: ...
    @property
    def AttenuationVector(self) -> Vector3d: ...
    @AttenuationVector.setter
    def AttenuationVector(self, value: Vector3d) -> None: ...
    def GetAttenuation(self, d: float) -> float: ...
    @property
    def SpotAngleRadians(self) -> float: ...
    @SpotAngleRadians.setter
    def SpotAngleRadians(self, value: float) -> None: ...
    @property
    def SpotExponent(self) -> float: ...
    @SpotExponent.setter
    def SpotExponent(self, value: float) -> None: ...
    @property
    def HotSpot(self) -> float: ...
    @HotSpot.setter
    def HotSpot(self, value: float) -> None: ...
    def GetSpotLightRadii(self) -> Tuple[bool, float, float]: ...
    @property
    def Length(self) -> Vector3d: ...
    @Length.setter
    def Length(self, value: Vector3d) -> None: ...
    @property
    def Width(self) -> Vector3d: ...
    @Width.setter
    def Width(self, value: Vector3d) -> None: ...
    @property
    def SpotLightShadowIntensity(self) -> float: ...
    @SpotLightShadowIntensity.setter
    def SpotLightShadowIntensity(self, value: float) -> None: ...
    @property
    def ShadowIntensity(self) -> float: ...
    @ShadowIntensity.setter
    def ShadowIntensity(self, value: float) -> None: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> None: ...
    @property
    def Id(self) -> Guid: ...
    @Id.setter
    def Id(self, value: Guid) -> None: ...


class LineCurve(Curve):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: LineCurve): ...
    @overload
    def __init__(self, from_: Point2d, to: Point2d): ...
    @overload
    def __init__(self, from_: Point3d, to: Point3d): ...
    @overload
    def __init__(self, line: Line): ...
    @overload
    def __init__(self, line: Line, t0: float, t1: float): ...
    @property
    def Line(self) -> Line: ...
    @Line.setter
    def Line(self, value: Line) -> None: ...


class AreaMassProperties:
    def Dispose(self) -> None: ...
    @overload
    def Compute(closedPlanarCurve: Curve) -> AreaMassProperties: ...
    @overload
    def Compute(closedPlanarCurve: Curve, planarTolerance: float) -> AreaMassProperties: ...
    @overload
    def Compute(hatch: Hatch) -> AreaMassProperties: ...
    @overload
    def Compute(mesh: Mesh) -> AreaMassProperties: ...
    @overload
    def Compute(mesh: Mesh, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    def Compute(brep: Brep) -> AreaMassProperties: ...
    @overload
    def Compute(brep: Brep, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    def Compute(surface: Surface) -> AreaMassProperties: ...
    @overload
    def Compute(surface: Surface, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    def Compute(geometry: Iterable[GeometryBase]) -> AreaMassProperties: ...
    @overload
    def Compute(geometry: Iterable[GeometryBase], area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @property
    def Area(self) -> float: ...
    @property
    def AreaError(self) -> float: ...
    @property
    def Centroid(self) -> Point3d: ...
    @property
    def CentroidError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    def WorldCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...
    def CentroidCoordinatesPrincipalMoments(self) -> Tuple[bool, float, Vector3d, float, Vector3d, float, Vector3d]: ...


class VolumeMassProperties:
    def Dispose(self) -> None: ...
    @overload
    def Compute(mesh: Mesh) -> VolumeMassProperties: ...
    @overload
    def Compute(mesh: Mesh, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    def Compute(brep: Brep) -> VolumeMassProperties: ...
    @overload
    def Compute(brep: Brep, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    def Compute(surface: Surface) -> VolumeMassProperties: ...
    @overload
    def Compute(surface: Surface, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    def Compute(geometry: Iterable[GeometryBase]) -> VolumeMassProperties: ...
    @overload
    def Compute(geometry: Iterable[GeometryBase], volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @property
    def Volume(self) -> float: ...
    @property
    def VolumeError(self) -> float: ...
    @property
    def Centroid(self) -> Point3d: ...
    @property
    def CentroidError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    def Sum(self, summand: VolumeMassProperties) -> bool: ...


class Matrix:
    @overload
    def __init__(self, rowCount: int, columnCount: int): ...
    @overload
    def __init__(self, xform: Transform): ...
    def Duplicate(self) -> Matrix: ...
    def Dispose(self) -> None: ...
    @property
    def Item(self, row: int, column: int) -> float: ...
    @Item.setter
    def Item(self, row: int, column: int, value: float) -> None: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsSquare(self) -> bool: ...
    @property
    def RowCount(self) -> int: ...
    @property
    def ColumnCount(self) -> int: ...
    def Zero(self) -> None: ...
    def SetDiagonal(self, d: float) -> None: ...
    def Transpose(self) -> bool: ...
    def SwapRows(self, rowA: int, rowB: int) -> bool: ...
    def SwapColumns(self, columnA: int, columnB: int) -> bool: ...
    def Invert(self, zeroTolerance: float) -> bool: ...
    def op_Multiply(a: Matrix, b: Matrix) -> Matrix: ...
    def op_Addition(a: Matrix, b: Matrix) -> Matrix: ...
    def Scale(self, s: float) -> None: ...
    @overload
    def RowReduce(self, zeroTolerance: float) -> Tuple[int, float, float]: ...
    @overload
    def RowReduce(self, zeroTolerance: float, b: Set(float)) -> Tuple[int, float]: ...
    @overload
    def RowReduce(self, zeroTolerance: float, b: Set(Point3d)) -> Tuple[int, float]: ...
    def BackSolve(self, zeroTolerance: float, b: Set(float)) -> Set(float): ...
    def BackSolvePoints(self, zeroTolerance: float, b: Set(Point3d)) -> Set(Point3d): ...
    @property
    def IsRowOrthogonal(self) -> bool: ...
    @property
    def IsColumnOrthogonal(self) -> bool: ...
    @property
    def IsRowOrthoNormal(self) -> bool: ...
    @property
    def IsColumnOrthoNormal(self) -> bool: ...
    def GetHashCode(self) -> int: ...


class MeshingParameterStyle:
    #None = 0
    Fast = 1
    Quality = 2
    Custom = 9
    PerObject = 10


class SmoothingCoordinateSystem:
    World = 0
    CPlane = 1
    Object = 2


class MeshingParameterTextureRange:
    Unset = 0
    UnpackedUnscaledNormalized = 1
    PackedScaledNormalized = 2


class MeshingParameters:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, density: float): ...
    @overload
    def __init__(self, density: float, minimumEdgeLength: float): ...
    def Dispose(self) -> None: ...
    def DocumentCurrentSetting(doc: RhinoDoc) -> MeshingParameters: ...
    @property
    def Minimal() -> MeshingParameters: ...
    @property
    def Default() -> MeshingParameters: ...
    @property
    def Coarse() -> MeshingParameters: ...
    @property
    def FastRenderMesh() -> MeshingParameters: ...
    @property
    def Smooth() -> MeshingParameters: ...
    @property
    def QualityRenderMesh() -> MeshingParameters: ...
    @property
    def DefaultAnalysisMesh() -> MeshingParameters: ...
    @property
    def TextureRange(self) -> MeshingParameterTextureRange: ...
    @TextureRange.setter
    def TextureRange(self, value: MeshingParameterTextureRange) -> None: ...
    @property
    def JaggedSeams(self) -> bool: ...
    @JaggedSeams.setter
    def JaggedSeams(self, value: bool) -> None: ...
    @property
    def RefineGrid(self) -> bool: ...
    @RefineGrid.setter
    def RefineGrid(self, value: bool) -> None: ...
    @property
    def SimplePlanes(self) -> bool: ...
    @SimplePlanes.setter
    def SimplePlanes(self, value: bool) -> None: ...
    @property
    def ComputeCurvature(self) -> bool: ...
    @ComputeCurvature.setter
    def ComputeCurvature(self, value: bool) -> None: ...
    @property
    def ClosedObjectPostProcess(self) -> bool: ...
    @ClosedObjectPostProcess.setter
    def ClosedObjectPostProcess(self, value: bool) -> None: ...
    @property
    def GridMinCount(self) -> int: ...
    @GridMinCount.setter
    def GridMinCount(self, value: int) -> None: ...
    @property
    def GridMaxCount(self) -> int: ...
    @GridMaxCount.setter
    def GridMaxCount(self, value: int) -> None: ...
    @property
    def GridAngle(self) -> float: ...
    @GridAngle.setter
    def GridAngle(self, value: float) -> None: ...
    @property
    def GridAspectRatio(self) -> float: ...
    @GridAspectRatio.setter
    def GridAspectRatio(self, value: float) -> None: ...
    @property
    def GridAmplification(self) -> float: ...
    @GridAmplification.setter
    def GridAmplification(self, value: float) -> None: ...
    @property
    def Tolerance(self) -> float: ...
    @Tolerance.setter
    def Tolerance(self, value: float) -> None: ...
    @property
    def MinimumTolerance(self) -> float: ...
    @MinimumTolerance.setter
    def MinimumTolerance(self, value: float) -> None: ...
    @property
    def RelativeTolerance(self) -> float: ...
    @RelativeTolerance.setter
    def RelativeTolerance(self, value: float) -> None: ...
    @property
    def MinimumEdgeLength(self) -> float: ...
    @MinimumEdgeLength.setter
    def MinimumEdgeLength(self, value: float) -> None: ...
    @property
    def MaximumEdgeLength(self) -> float: ...
    @MaximumEdgeLength.setter
    def MaximumEdgeLength(self, value: float) -> None: ...
    @property
    def RefineAngle(self) -> float: ...
    @RefineAngle.setter
    def RefineAngle(self, value: float) -> None: ...


class MeshPart:
    @property
    def StartVertexIndex(self) -> int: ...
    @property
    def EndVertexIndex(self) -> int: ...
    @property
    def StartFaceIndex(self) -> int: ...
    @property
    def EndFaceIndex(self) -> int: ...
    @property
    def VertexCount(self) -> int: ...
    @property
    def TriangleCount(self) -> int: ...


class MeshThicknessMeasurement:
    def __init__(self, meshIndex: int, vertexIndex: int, thickness: float, point: Point3d, oppositePoint: Point3d): ...
    @property
    def MeshIndex(self) -> int: ...
    @property
    def VertexIndex(self) -> int: ...
    @property
    def Thickness(self) -> float: ...
    @property
    def Point(self) -> Point3d: ...
    @property
    def OppositePoint(self) -> Point3d: ...


class ReduceMeshParameters:
    def __init__(self): ...
    @property
    def DesiredPolygonCount(self) -> int: ...
    @DesiredPolygonCount.setter
    def DesiredPolygonCount(self, value: int) -> None: ...
    @property
    def AllowDistortion(self) -> bool: ...
    @AllowDistortion.setter
    def AllowDistortion(self, value: bool) -> None: ...
    @property
    def Accuracy(self) -> int: ...
    @Accuracy.setter
    def Accuracy(self, value: int) -> None: ...
    @property
    def NormalizeMeshSize(self) -> bool: ...
    @NormalizeMeshSize.setter
    def NormalizeMeshSize(self, value: bool) -> None: ...
    @property
    def Error(self) -> str: ...
    @property
    def FaceTags(self) -> Set(int): ...
    @FaceTags.setter
    def FaceTags(self, value: Set(int)) -> None: ...
    @property
    def LockedComponents(self) -> Set(ComponentIndex): ...
    @LockedComponents.setter
    def LockedComponents(self, value: Set(ComponentIndex)) -> None: ...
    @property
    def CancelToken(self) -> CancellationToken: ...
    @CancelToken.setter
    def CancelToken(self, value: CancellationToken) -> None: ...
    @property
    def ProgressReporter(self) -> IProgress: ...
    @ProgressReporter.setter
    def ProgressReporter(self, value: IProgress) -> None: ...


class QuadRemeshParameters:
    def __init__(self): ...
    @property
    def TargetQuadCount(self) -> int: ...
    @TargetQuadCount.setter
    def TargetQuadCount(self, value: int) -> None: ...
    @property
    def AdaptiveSize(self) -> float: ...
    @AdaptiveSize.setter
    def AdaptiveSize(self, value: float) -> None: ...
    @property
    def AdaptiveQuadCount(self) -> bool: ...
    @AdaptiveQuadCount.setter
    def AdaptiveQuadCount(self, value: bool) -> None: ...
    @property
    def DetectHardEdges(self) -> bool: ...
    @DetectHardEdges.setter
    def DetectHardEdges(self, value: bool) -> None: ...
    @property
    def GuideCurveInfluence(self) -> int: ...
    @GuideCurveInfluence.setter
    def GuideCurveInfluence(self, value: int) -> None: ...
    @property
    def PreserveMeshArrayEdgesMode(self) -> int: ...
    @PreserveMeshArrayEdgesMode.setter
    def PreserveMeshArrayEdgesMode(self, value: int) -> None: ...
    @property
    def SymmetryAxis(self) -> QuadRemeshSymmetryAxis: ...
    @SymmetryAxis.setter
    def SymmetryAxis(self, value: QuadRemeshSymmetryAxis) -> None: ...


class QuadRemeshSymmetryAxis:
    #None = 0
    X = 1
    Y = 2
    Z = 4


class Mesh(GeometryBase):
    def __init__(self): ...
    @overload
    def Split(self, mesh: Mesh) -> Set(Mesh): ...
    @overload
    def Split(self, meshes: Iterable[Mesh]) -> Set(Mesh): ...
    @overload
    def GetOutlines(self, plane: Plane) -> Set(Polyline): ...
    @overload
    def GetOutlines(self, viewport: RhinoViewport) -> Set(Polyline): ...
    @overload
    def GetOutlines(self, viewportInfo: ViewportInfo, plane: Plane) -> Set(Polyline): ...
    def GetNakedEdges(self) -> Set(Polyline): ...
    def ExplodeAtUnweldedEdges(self) -> Set(Mesh): ...
    @overload
    def Append(self, other: Mesh) -> None: ...
    @overload
    def Append(self, meshes: Iterable[Mesh]) -> None: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    def ClosestMeshPoint(self, testPoint: Point3d, maximumDistance: float) -> MeshPoint: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[int, Point3d]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[int, Point3d, Vector3d]: ...
    @overload
    def PointAt(self, meshPoint: MeshPoint) -> Point3d: ...
    @overload
    def PointAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Point3d: ...
    @overload
    def NormalAt(self, meshPoint: MeshPoint) -> Vector3d: ...
    @overload
    def NormalAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Vector3d: ...
    @overload
    def ColorAt(self, meshPoint: MeshPoint) -> Color: ...
    @overload
    def ColorAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Color: ...
    def PullPointsToMesh(self, points: Iterable[Point3d]) -> Set(Point3d): ...
    @overload
    def Offset(self, distance: float) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool, direction: Vector3d) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool, direction: Vector3d) -> Tuple[Mesh, List]: ...
    def CollapseFacesByEdgeLength(self, bGreaterThan: bool, edgeLength: float) -> int: ...
    def CollapseFacesByArea(self, lessThanArea: float, greaterThanArea: float) -> int: ...
    def CollapseFacesByByAspectRatio(self, aspectRatio: float) -> int: ...
    def GetUnsafeLock(self, writable: bool) -> MeshUnsafeLock: ...
    def ReleaseUnsafeLock(self, meshData: MeshUnsafeLock) -> None: ...
    def WithShutLining(self, faceted: bool, tolerance: float, curves: Iterable[ShutLiningCurveInfo]) -> Mesh: ...
    def WithDisplacement(self, displacement: MeshDisplacementInfo) -> Mesh: ...
    def WithEdgeSoftening(self, softeningRadius: float, chamfer: bool, faceted: bool, force: bool, angleThreshold: float) -> Mesh: ...
    def GetNakedEdgePointStatus(self) -> Set(bool): ...
    def CreatePartitions(self, maximumVertexCount: int, maximumTriangleCount: int) -> bool: ...
    @property
    def PartitionCount(self) -> int: ...
    def GetPartition(self, which: int) -> MeshPart: ...
    def GetNgonAndFacesEnumerable(self) -> Iterable[MeshNgon]: ...
    def GetNgonAndFacesCount(self) -> int: ...
    @overload
    def QuadRemeshBrep(brep: Brep, parameters: QuadRemeshParameters) -> Mesh: ...
    @overload
    def QuadRemeshBrep(brep: Brep, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve]) -> Mesh: ...
    @overload
    def QuadRemeshBrepAsync(brep: Brep, parameters: QuadRemeshParameters, progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    def QuadRemeshBrepAsync(brep: Brep, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve], progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    def QuadRemesh(self, parameters: QuadRemeshParameters) -> Mesh: ...
    @overload
    def QuadRemesh(self, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve]) -> Mesh: ...
    @overload
    def QuadRemeshAsync(self, parameters: QuadRemeshParameters, progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    def QuadRemeshAsync(self, parameters: QuadRemeshParameters, guideCurves: Iterable[Curve], progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    def QuadRemeshAsync(self, faceBlocks: Iterable[int], parameters: QuadRemeshParameters, guideCurves: Iterable[Curve], progress: IProgress, cancelToken: CancellationToken) -> Task: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool) -> bool: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, threaded: bool) -> bool: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: CancellationToken, progress: IProgress) -> Tuple[bool, str]: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: CancellationToken, progress: IProgress, threaded: bool) -> Tuple[bool, str]: ...
    @overload
    def Reduce(self, parameters: ReduceMeshParameters) -> bool: ...
    @overload
    def Reduce(self, parameters: ReduceMeshParameters, threaded: bool) -> bool: ...
    @overload
    def ComputeThickness(meshes: Iterable[Mesh], maximumThickness: float) -> Set(MeshThicknessMeasurement): ...
    @overload
    def ComputeThickness(meshes: Iterable[Mesh], maximumThickness: float, cancelToken: CancellationToken) -> Set(MeshThicknessMeasurement): ...
    @overload
    def ComputeThickness(meshes: Iterable[Mesh], maximumThickness: float, sharpAngle: float, cancelToken: CancellationToken) -> Set(MeshThicknessMeasurement): ...
    @overload
    def CreateContourCurves(meshToContour: Mesh, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Set(Curve): ...
    @overload
    def CreateContourCurves(meshToContour: Mesh, sectionPlane: Plane) -> Set(Curve): ...
    def CreateFromLines(lines: Set(Curve), maxFaceValence: int, tolerance: float) -> Mesh: ...
    def CreateRefinedLoopMesh(mesh: Mesh, formula: LoopFormula, settings: RefinementSettings) -> Mesh: ...
    def CreateRefinedCatmullClarkMesh(mesh: Mesh, settings: RefinementSettings) -> Mesh: ...
    def ComputeAutoCreaseInformation(self) -> Set(Byte): ...
    def ExtendSelectionByEdgeRidge(self, preselectedEdges: Set(int), newEdge: int, iterative: bool) -> Set(int): ...
    def ExtendSelectionByFaceLoop(self, preselectedFaces: Set(int), newFace: int, iterative: bool) -> Set(int): ...
    def CreateFromPlane(plane: Plane, xInterval: Interval, yInterval: Interval, xCount: int, yCount: int) -> Mesh: ...
    @overload
    def CreateFromBox(box: BoundingBox, xCount: int, yCount: int, zCount: int) -> Mesh: ...
    @overload
    def CreateFromBox(box: Box, xCount: int, yCount: int, zCount: int) -> Mesh: ...
    @overload
    def CreateFromBox(corners: Iterable[Point3d], xCount: int, yCount: int, zCount: int) -> Mesh: ...
    def CreateFromSphere(sphere: Sphere, xCount: int, yCount: int) -> Mesh: ...
    def CreateIcoSphere(sphere: Sphere, subdivisions: int) -> Mesh: ...
    def CreateQuadSphere(sphere: Sphere, subdivisions: int) -> Mesh: ...
    @overload
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int) -> Mesh: ...
    @overload
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool) -> Mesh: ...
    @overload
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool, quadCaps: bool) -> Mesh: ...
    @overload
    def CreateFromCone(cone: Cone, vertical: int, around: int) -> Mesh: ...
    @overload
    def CreateFromCone(cone: Cone, vertical: int, around: int, solid: bool) -> Mesh: ...
    @overload
    def CreateFromCone(cone: Cone, vertical: int, around: int, solid: bool, quadCaps: bool) -> Mesh: ...
    def CreateFromTorus(torus: Torus, vertical: int, around: int) -> Mesh: ...
    @overload
    def CreateFromPlanarBoundary(boundary: Curve, parameters: MeshingParameters) -> Mesh: ...
    @overload
    def CreateFromPlanarBoundary(boundary: Curve, parameters: MeshingParameters, tolerance: float) -> Mesh: ...
    def CreateFromClosedPolyline(polyline: Polyline) -> Mesh: ...
    def CreateFromTessellation(points: Iterable[Point3d], edges: Iterable[Iterable[Point3d]], plane: Plane, allowNewVertices: bool) -> Mesh: ...
    @overload
    def CreateFromBrep(brep: Brep) -> Set(Mesh): ...
    @overload
    def CreateFromBrep(brep: Brep, meshingParameters: MeshingParameters) -> Set(Mesh): ...
    @overload
    def CreateFromSurface(surface: Surface) -> Mesh: ...
    @overload
    def CreateFromSurface(surface: Surface, meshingParameters: MeshingParameters) -> Mesh: ...
    def CreateFromSubD(subd: SubD, displayDensity: int) -> Mesh: ...
    def CreateFromSubDControlNet(subd: SubD) -> Mesh: ...
    def CreatePatch(outerBoundary: Polyline, angleToleranceRadians: float, pullbackSurface: Surface, innerBoundaryCurves: Iterable[Curve], innerBothSideCurves: Iterable[Curve], innerPoints: Iterable[Point3d], trimback: bool, divisions: int) -> Mesh: ...
    def CreateBooleanUnion(meshes: Iterable[Mesh]) -> Set(Mesh): ...
    def CreateBooleanDifference(firstSet: Iterable[Mesh], secondSet: Iterable[Mesh]) -> Set(Mesh): ...
    def CreateBooleanIntersection(firstSet: Iterable[Mesh], secondSet: Iterable[Mesh]) -> Set(Mesh): ...
    def CreateBooleanSplit(meshesToSplit: Iterable[Mesh], meshSplitters: Iterable[Mesh]) -> Set(Mesh): ...
    def CreateFromCurvePipe(curve: Curve, radius: float, segments: int, accuracy: int, capType: MeshPipeCapStyle, faceted: bool, intervals: Iterable[Interval]) -> Mesh: ...
    def CopyFrom(self, other: Mesh) -> None: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateMesh(self) -> Mesh: ...
    @property
    def DisjointMeshCount(self) -> int: ...
    @property
    def IsClosed(self) -> bool: ...
    def IsManifold(self, topologicalTest: bool) -> Tuple[bool, bool, bool]: ...
    @property
    def HasCachedTextureCoordinates(self) -> bool: ...
    @property
    def Vertices(self) -> MeshVertexList: ...
    @property
    def TopologyVertices(self) -> MeshTopologyVertexList: ...
    @property
    def TopologyEdges(self) -> MeshTopologyEdgeList: ...
    @property
    def Normals(self) -> MeshVertexNormalList: ...
    @property
    def Faces(self) -> MeshFaceList: ...
    @property
    def Ngons(self) -> MeshNgonList: ...
    @property
    def FaceNormals(self) -> MeshFaceNormalList: ...
    @property
    def VertexColors(self) -> MeshVertexColorList: ...
    @property
    def TextureCoordinates(self) -> MeshTextureCoordinateList: ...
    @property
    def ComponentStates(self) -> MeshVertexStatusList: ...
    def ClearTextureData(self) -> None: ...
    def ClearSurfaceData(self) -> None: ...
    def DestroyTopology(self) -> None: ...
    def DestroyTree(self) -> None: ...
    def DestroyPartition(self) -> None: ...
    def EvaluateMeshGeometry(self, surface: Surface) -> bool: ...
    def SetTextureCoordinates(self, tm: TextureMapping, xf: Transform, lazy: bool) -> None: ...
    def SetCachedTextureCoordinates(self, tm: TextureMapping, xf: Transform) -> Tuple[Transform]: ...
    def GetCachedTextureCoordinates(self, textureMappingId: Guid) -> CachedTextureCoordinates: ...
    def Compact(self) -> bool: ...
    def Volume(self) -> float: ...
    def Flip(self, vertexNormals: bool, faceNormals: bool, faceOrientation: bool) -> None: ...
    def SolidOrientation(self) -> int: ...
    def IsPointInside(self, point: Point3d, tolerance: float, strictlyIn: bool) -> bool: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> bool: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    @overload
    def Smooth(self, vertexIndices: Iterable[int], smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    def Unweld(self, angleToleranceRadians: float, modifyNormals: bool) -> None: ...
    def UnweldEdge(self, edgeIndices: Iterable[int], modifyNormals: bool) -> bool: ...
    def Weld(self, angleToleranceRadians: float) -> None: ...
    def RebuildNormals(self) -> None: ...
    def ExtractNonManifoldEdges(self, selective: bool) -> Mesh: ...
    def HealNakedEdges(self, distance: float) -> bool: ...
    def FillHoles(self) -> bool: ...
    def FileHole(self, topologyEdgeIndex: int) -> bool: ...
    @overload
    def UnifyNormals(self) -> int: ...
    @overload
    def UnifyNormals(self, countOnly: bool) -> int: ...
    def SplitDisjointPieces(self) -> Set(Mesh): ...
    @overload
    def Split(self, plane: Plane) -> Set(Mesh): ...


class MeshUnsafeLock:
    def VertexPoint3fArray(self) -> Tuple[Point3f, int]: ...
    def Release(self) -> None: ...


class MeshFace:
    @overload
    def __init__(self, a: int, b: int, c: int): ...
    @overload
    def __init__(self, a: int, b: int, c: int, d: int): ...
    @property
    def Unset() -> MeshFace: ...
    @property
    def A(self) -> int: ...
    @A.setter
    def A(self, value: int) -> None: ...
    @property
    def B(self) -> int: ...
    @B.setter
    def B(self, value: int) -> None: ...
    @property
    def C(self) -> int: ...
    @C.setter
    def C(self, value: int) -> None: ...
    @property
    def D(self) -> int: ...
    @D.setter
    def D(self, value: int) -> None: ...
    @property
    def Item(self, index: int) -> int: ...
    @Item.setter
    def Item(self, index: int, value: int) -> None: ...
    @overload
    def IsValid(self) -> bool: ...
    @overload
    def IsValid(self, vertexCount: int) -> bool: ...
    @overload
    def IsValid(self, points: Set(Point3d)) -> bool: ...
    def Repair(self, points: Set(Point3d)) -> bool: ...
    def IsValidEx(self, points: Set(Point3d)) -> Tuple[bool, Set(Point3d)]: ...
    def RepairEx(self, points: Set(Point3d)) -> Tuple[bool, Set(Point3d)]: ...
    @property
    def IsTriangle(self) -> bool: ...
    @property
    def IsQuad(self) -> bool: ...
    @overload
    def Set(self, a: int, b: int, c: int) -> None: ...
    @overload
    def Set(self, a: int, b: int, c: int, d: int) -> None: ...
    def Flip(self) -> MeshFace: ...
    @overload
    def Equals(self, other: MeshFace) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    def GetHashCode(self) -> int: ...
    def op_Equality(a: MeshFace, b: MeshFace) -> bool: ...
    def op_Inequality(a: MeshFace, b: MeshFace) -> bool: ...
    def ToString(self) -> str: ...
    def CompareTo(self, other: MeshFace) -> int: ...


class MeshNgon:
    def Create(meshVertexIndexList: List[int], meshFaceIndexList: List[int]) -> MeshNgon: ...
    @property
    def Empty() -> MeshNgon: ...
    @property
    def BoundaryVertexCount(self) -> int: ...
    @property
    def FaceCount(self) -> int: ...
    @property
    def Item(self, index: int) -> int: ...
    def BoundaryVertexIndexList(self) -> Set(UInt32): ...
    def FaceIndexList(self) -> Set(UInt32): ...
    def Set(self, meshVertexIndexList: List[int], meshFaceIndexList: List[int]) -> None: ...
    @overload
    def Equals(self, otherNgon: MeshNgon) -> bool: ...
    @overload
    def Equals(self, otherObj: Object) -> bool: ...
    def GetHashCode(self) -> int: ...
    def op_Equality(a: MeshNgon, b: MeshNgon) -> bool: ...
    def op_Inequality(a: MeshNgon, b: MeshNgon) -> bool: ...
    def ToString(self) -> str: ...
    def CompareTo(self, otherNgon: MeshNgon) -> int: ...


class ShutLiningCurveInfo:
    def __init__(self, curve: Curve, radius: float, profile: int, pull: bool, isBump: bool, curveIntervals: Iterable[Interval], enabled: bool): ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def Enabled(self) -> bool: ...
    @property
    def Radius(self) -> float: ...
    @property
    def Profile(self) -> int: ...
    @property
    def Pull(self) -> bool: ...
    @property
    def IsBump(self) -> bool: ...
    @property
    def CurveIntervals(self) -> ReadOnlyCollection: ...


class MeshDisplacementInfo:
    def __init__(self, texture: RenderTexture, mapping: TextureMapping): ...
    @property
    def Texture(self) -> RenderTexture: ...
    @property
    def Black(self) -> float: ...
    @Black.setter
    def Black(self, value: float) -> None: ...
    @property
    def White(self) -> float: ...
    @White.setter
    def White(self, value: float) -> None: ...
    @property
    def Mapping(self) -> TextureMapping: ...
    @property
    def MappingTransform(self) -> Transform: ...
    @MappingTransform.setter
    def MappingTransform(self, value: Transform) -> None: ...
    @property
    def InstanceTransform(self) -> Transform: ...
    @InstanceTransform.setter
    def InstanceTransform(self, value: Transform) -> None: ...
    @property
    def BlackMove(self) -> float: ...
    @BlackMove.setter
    def BlackMove(self, value: float) -> None: ...
    @property
    def PostWeldAngle(self) -> float: ...
    @PostWeldAngle.setter
    def PostWeldAngle(self, value: float) -> None: ...
    @property
    def RefineSensitivity(self) -> float: ...
    @RefineSensitivity.setter
    def RefineSensitivity(self, value: float) -> None: ...
    @property
    def SweepPitch(self) -> float: ...
    @SweepPitch.setter
    def SweepPitch(self, value: float) -> None: ...
    @property
    def WhiteMove(self) -> float: ...
    @WhiteMove.setter
    def WhiteMove(self, value: float) -> None: ...
    @property
    def ChannelNumber(self) -> int: ...
    @ChannelNumber.setter
    def ChannelNumber(self, value: int) -> None: ...
    @property
    def FaceLimit(self) -> int: ...
    @FaceLimit.setter
    def FaceLimit(self, value: int) -> None: ...
    @property
    def FairingAmount(self) -> int: ...
    @FairingAmount.setter
    def FairingAmount(self, value: int) -> None: ...
    @property
    def RefineStepCount(self) -> int: ...
    @RefineStepCount.setter
    def RefineStepCount(self, value: int) -> None: ...
    @property
    def MemoryLimit(self) -> int: ...
    @MemoryLimit.setter
    def MemoryLimit(self, value: int) -> None: ...


class NurbsSurface(Surface):
    def __init__(self, other: NurbsSurface): ...
    def Create(dimension: int, isRational: bool, order0: int, order1: int, controlPointCount0: int, controlPointCount1: int) -> NurbsSurface: ...
    def CreateFromCone(cone: Cone) -> NurbsSurface: ...
    def CreateFromCylinder(cylinder: Cylinder) -> NurbsSurface: ...
    def CreateFromSphere(sphere: Sphere) -> NurbsSurface: ...
    def CreateFromTorus(torus: Torus) -> NurbsSurface: ...
    def CreateRuledSurface(curveA: Curve, curveB: Curve) -> NurbsSurface: ...
    def CreateCurveOnSurfacePoints(surface: Surface, fixedPoints: Iterable[Point2d], tolerance: float, periodic: bool, initCount: int, levels: int) -> Set(Point2d): ...
    def CreateCurveOnSurface(surface: Surface, points: Iterable[Point2d], tolerance: float, periodic: bool) -> NurbsCurve: ...
    def MakeCompatible(surface0: Surface, surface1: Surface) -> Tuple[bool, NurbsSurface, NurbsSurface]: ...
    def CreateFromPoints(points: Iterable[Point3d], uCount: int, vCount: int, uDegree: int, vDegree: int) -> NurbsSurface: ...
    def CreateThroughPoints(points: Iterable[Point3d], uCount: int, vCount: int, uDegree: int, vDegree: int, uClosed: bool, vClosed: bool) -> NurbsSurface: ...
    @overload
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d) -> NurbsSurface: ...
    @overload
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d, tolerance: float) -> NurbsSurface: ...
    @overload
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d) -> NurbsSurface: ...
    def CreateRailRevolvedSurface(profile: Curve, rail: Curve, axis: Line, scaleHeight: bool) -> NurbsSurface: ...
    @overload
    def CreateNetworkSurface(uCurves: Iterable[Curve], uContinuityStart: int, uContinuityEnd: int, vCurves: Iterable[Curve], vContinuityStart: int, vContinuityEnd: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    def CreateNetworkSurface(curves: Iterable[Curve], continuity: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float) -> Tuple[NurbsSurface, int]: ...
    def UVNDirectionsAt(self, u: float, v: float) -> Tuple[bool, Vector3d, Vector3d, Vector3d]: ...
    @property
    def KnotsU(self) -> NurbsSurfaceKnotList: ...
    @property
    def KnotsV(self) -> NurbsSurfaceKnotList: ...
    @property
    def Points(self) -> NurbsSurfacePointList: ...
    @property
    def IsRational(self) -> bool: ...
    def MakeRational(self) -> bool: ...
    def MakeNonRational(self) -> bool: ...
    def IncreaseDegreeU(self, desiredDegree: int) -> bool: ...
    def IncreaseDegreeV(self, desiredDegree: int) -> bool: ...
    def CopyFrom(self, other: NurbsSurface) -> None: ...
    def EpsilonEquals(self, other: NurbsSurface, epsilon: float) -> bool: ...
    @property
    def OrderU(self) -> int: ...
    @property
    def OrderV(self) -> int: ...


class MorphControl(GeometryBase):
    def __init__(self, originCurve: NurbsCurve, targetCurve: NurbsCurve): ...
    @property
    def SpaceMorphTolerance(self) -> float: ...
    @SpaceMorphTolerance.setter
    def SpaceMorphTolerance(self, value: float) -> None: ...
    @property
    def QuickPreview(self) -> bool: ...
    @QuickPreview.setter
    def QuickPreview(self, value: bool) -> None: ...
    @property
    def PreserveStructure(self) -> bool: ...
    @PreserveStructure.setter
    def PreserveStructure(self, value: bool) -> None: ...
    @property
    def Curve(self) -> NurbsCurve: ...
    @property
    def Surface(self) -> NurbsSurface: ...
    def Morph(self, geometry: GeometryBase) -> bool: ...


class PlaneSurface(Surface):
    def __init__(self, plane: Plane, xExtents: Interval, yExtents: Interval): ...
    @overload
    def CreateThroughBox(lineInPlane: Line, vectorInPlane: Vector3d, box: BoundingBox) -> PlaneSurface: ...
    @overload
    def CreateThroughBox(plane: Plane, box: BoundingBox) -> PlaneSurface: ...


class ClippingPlaneSurface(PlaneSurface):
    @property
    def Plane(self) -> Plane: ...
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    def ViewportIds(self) -> Set(Guid): ...
    def AddClipViewportId(self, viewportId: Guid) -> bool: ...
    def RemoveClipViewportId(self, viewportId: Guid) -> bool: ...


class MeshPoint:
    @property
    def Mesh(self) -> Mesh: ...
    @property
    def EdgeParameter(self) -> float: ...
    @property
    def ComponentIndex(self) -> ComponentIndex: ...
    @property
    def EdgeIndex(self) -> int: ...
    @property
    def FaceIndex(self) -> int: ...
    def GetTriangle(self) -> Tuple[bool, int, int, int]: ...
    @property
    def Triangle(self) -> Char: ...
    @property
    def T(self) -> Set(float): ...
    @property
    def Point(self) -> Point3d: ...


class SilhouetteType:
    #None = 0
    Projecting = 1
    TangentProjects = 2
    Tangent = 4
    Crease = 8
    Boundary = 16
    NonSilhouetteCrease = 256
    NonSilhouetteTangent = 512
    NonSilhouetteSeam = 1024
    SectionCut = 4096
    MiscellaneousFeature = 8192
    DraftCurve = 32768


class Silhouette:
    @overload
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, perspectiveCameraLocation: Point3d, tolerance: float, angleToleranceRadians: float) -> Set(Silhouette): ...
    @overload
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, perspectiveCameraLocation: Point3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Plane], cancelToken: CancellationToken) -> Set(Silhouette): ...
    @overload
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, parallelCameraDirection: Vector3d, tolerance: float, angleToleranceRadians: float) -> Set(Silhouette): ...
    @overload
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, parallelCameraDirection: Vector3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Plane], cancelToken: CancellationToken) -> Set(Silhouette): ...
    @overload
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, viewport: ViewportInfo, tolerance: float, angleToleranceRadians: float) -> Set(Silhouette): ...
    @overload
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, viewport: ViewportInfo, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Plane], cancelToken: CancellationToken) -> Set(Silhouette): ...
    @property
    def SilhouetteType(self) -> SilhouetteType: ...
    @property
    def GeometryComponentIndex(self) -> ComponentIndex: ...
    @property
    def Curve(self) -> Curve: ...


class PointCloudItem:
    @property
    def Location(self) -> Point3d: ...
    @Location.setter
    def Location(self, value: Point3d) -> None: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> None: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> None: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> None: ...
    @property
    def Normal(self) -> Vector3d: ...
    @Normal.setter
    def Normal(self, value: Vector3d) -> None: ...
    @property
    def Color(self) -> Color: ...
    @Color.setter
    def Color(self, value: Color) -> None: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> None: ...
    @property
    def Index(self) -> int: ...


class PointCloud(GeometryBase):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: PointCloud): ...
    @overload
    def __init__(self, points: Iterable[Point3d]): ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self, index: int) -> PointCloudItem: ...
    @property
    def HiddenPointCount(self) -> int: ...
    @property
    def ContainsColors(self) -> bool: ...
    @property
    def ContainsNormals(self) -> bool: ...
    @property
    def ContainsHiddenFlags(self) -> bool: ...
    def ClearColors(self) -> None: ...
    def ClearNormals(self) -> None: ...
    def ClearHiddenFlags(self) -> None: ...
    def AppendNew(self) -> PointCloudItem: ...
    def InsertNew(self, index: int) -> PointCloudItem: ...
    def Merge(self, other: PointCloud) -> None: ...
    @overload
    def Add(self, point: Point3d) -> None: ...
    @overload
    def Add(self, point: Point3d, normal: Vector3d) -> None: ...
    @overload
    def Add(self, point: Point3d, color: Color) -> None: ...
    @overload
    def Add(self, point: Point3d, normal: Vector3d, color: Color) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d]) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d], normals: Iterable[Vector3d]) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d], colors: Iterable[Color]) -> None: ...
    @overload
    def AddRange(self, points: Iterable[Point3d], normals: Iterable[Vector3d], colors: Iterable[Color]) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, normal: Vector3d) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, color: Color) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, normal: Vector3d, color: Color) -> None: ...
    def InsertRange(self, index: int, points: Iterable[Point3d]) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    def GetPoints(self) -> Set(Point3d): ...
    def PointAt(self, index: int) -> Point3d: ...
    def GetNormals(self) -> Set(Vector3d): ...
    def GetColors(self) -> Set(Color): ...
    def ClosestPoint(self, testPoint: Point3d) -> int: ...
    def AsReadOnlyListOfPoints(self) -> IReadOnlyList: ...
    def GetEnumerator(self) -> IEnumerator: ...


class Point(GeometryBase):
    def __init__(self, location: Point3d): ...
    @property
    def Location(self) -> Point3d: ...
    @Location.setter
    def Location(self, value: Point3d) -> None: ...


class Point3dGrid(GeometryBase):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, rows: int, columns: int): ...


class PolyCurve(Curve):
    def __init__(self): ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicatePolyCurve(self) -> PolyCurve: ...
    @property
    def SegmentCount(self) -> int: ...
    def SegmentCurve(self, index: int) -> Curve: ...
    @property
    def IsNested(self) -> bool: ...
    @property
    def HasGap(self) -> bool: ...
    def RemoveNesting(self) -> bool: ...
    def Explode(self) -> Set(Curve): ...
    @overload
    def Append(self, line: Line) -> bool: ...
    @overload
    def Append(self, arc: Arc) -> bool: ...
    @overload
    def Append(self, curve: Curve) -> bool: ...
    def AppendSegment(self, curve: Curve) -> bool: ...
    def SegmentCurveParameter(self, polycurveParameter: float) -> float: ...
    def PolyCurveParameter(self, segmentIndex: int, segmentCurveParameter: float) -> float: ...
    def SegmentDomain(self, segmentIndex: int) -> Interval: ...
    def SegmentIndex(self, polycurveParameter: float) -> int: ...
    def SegmentIndexes(self, subdomain: Interval) -> Tuple[int, int, int]: ...


class Polyline(Point3dList):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initialCapacity: int): ...
    @overload
    def __init__(self, collection: Iterable[Point3d]): ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def SegmentCount(self) -> int: ...
    @property
    def IsClosed(self) -> bool: ...
    def IsClosedWithinTolerance(self, tolerance: float) -> bool: ...
    @property
    def Length(self) -> float: ...
    def SegmentAt(self, index: int) -> Line: ...
    def PointAt(self, t: float) -> Point3d: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def Trim(self, domain: Interval) -> Polyline: ...
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    def GetSegments(self) -> Set(Line): ...
    def ToNurbsCurve(self) -> NurbsCurve: ...
    def ToPolylineCurve(self) -> PolylineCurve: ...
    def DeleteShortSegments(self, tolerance: float) -> int: ...
    def CollapseShortSegments(self, tolerance: float) -> int: ...
    def ReduceSegments(self, tolerance: float) -> int: ...
    def MergeColinearSegments(self, angleTolerance: float, includeSeam: bool) -> int: ...
    def Smooth(self, amount: float) -> bool: ...
    def BreakAtAngles(self, angle: float) -> Set(Polyline): ...
    def CenterPoint(self) -> Point3d: ...
    def CreateInscribedPolygon(circle: Circle, sideCount: int) -> Polyline: ...
    def CreateCircumscribedPolygon(circle: Circle, sideCount: int) -> Polyline: ...
    def CreateStarPolygon(circle: Circle, radius: float, cornerCount: int) -> Polyline: ...
    def TriangulateClosedPolyline(self) -> Set(MeshFace): ...
    @overload
    def Duplicate(self) -> Polyline: ...


class PolylineCurve(Curve):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: PolylineCurve): ...
    @overload
    def __init__(self, points: Iterable[Point3d]): ...
    @property
    def PointCount(self) -> int: ...
    def Point(self, index: int) -> Point3d: ...
    def SetPoint(self, index: int, point: Point3d) -> None: ...
    def Parameter(self, index: int) -> float: ...
    def SetParameter(self, index: int, parameter: float) -> None: ...
    @overload
    def ToPolyline(self) -> Polyline: ...


class Rectangle3d:
    @overload
    def __init__(self, plane: Plane, width: float, height: float): ...
    @overload
    def __init__(self, plane: Plane, width: Interval, height: Interval): ...
    @overload
    def __init__(self, plane: Plane, cornerA: Point3d, cornerB: Point3d): ...
    @overload
    def CreateFromPolyline(polyline: Iterable[Point3d]) -> Rectangle3d: ...
    @overload
    def CreateFromPolyline(polyline: Iterable[Point3d]) -> Tuple[Rectangle3d, float, float]: ...
    @property
    def Unset() -> Rectangle3d: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @property
    def X(self) -> Interval: ...
    @X.setter
    def X(self, value: Interval) -> None: ...
    @property
    def Y(self) -> Interval: ...
    @Y.setter
    def Y(self, value: Interval) -> None: ...
    @property
    def Width(self) -> float: ...
    @property
    def Height(self) -> float: ...
    @property
    def Area(self) -> float: ...
    @property
    def Circumference(self) -> float: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Center(self) -> Point3d: ...
    def MakeIncreasing(self) -> None: ...
    def Corner(self, index: int) -> Point3d: ...
    @overload
    def RecenterPlane(self, index: int) -> None: ...
    @overload
    def RecenterPlane(self, origin: Point3d) -> None: ...
    @overload
    def PointAt(self, x: float, y: float) -> Point3d: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, point: Point3d, includeInterior: bool) -> Point3d: ...
    @overload
    def Contains(self, pt: Point3d) -> PointContainment: ...
    @overload
    def Contains(self, x: float, y: float) -> PointContainment: ...
    def Transform(self, xform: Transform) -> bool: ...
    def ToPolyline(self) -> Polyline: ...
    def ToNurbsCurve(self) -> NurbsCurve: ...
    def EpsilonEquals(self, other: Rectangle3d, epsilon: float) -> bool: ...


class RevSurface(Surface):
    @property
    def Curve(self) -> Curve: ...
    @property
    def Axis(self) -> Line: ...
    @property
    def Angle(self) -> Interval: ...
    @overload
    def Create(revoluteCurve: Curve, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @overload
    def Create(revoluteCurve: Curve, axisOfRevolution: Line) -> RevSurface: ...
    @overload
    def Create(revoluteLine: Line, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @overload
    def Create(revoluteLine: Line, axisOfRevolution: Line) -> RevSurface: ...
    @overload
    def Create(revolutePolyline: Polyline, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @overload
    def Create(revolutePolyline: Polyline, axisOfRevolution: Line) -> RevSurface: ...
    def CreateFromCone(cone: Cone) -> RevSurface: ...
    def CreateFromCylinder(cylinder: Cylinder) -> RevSurface: ...
    def CreateFromSphere(sphere: Sphere) -> RevSurface: ...
    def CreateFromTorus(torus: Torus) -> RevSurface: ...


class RTreeEventArgs:
    @property
    def Id(self) -> int: ...
    @property
    def IdPtr(self) -> IntPtr: ...
    @property
    def Cancel(self) -> bool: ...
    @Cancel.setter
    def Cancel(self, value: bool) -> None: ...
    @property
    def IdB(self) -> int: ...
    @property
    def IdBPtr(self) -> IntPtr: ...
    @property
    def Tag(self) -> Object: ...
    @Tag.setter
    def Tag(self, value: Object) -> None: ...
    @property
    def SearchSphere(self) -> Sphere: ...
    @SearchSphere.setter
    def SearchSphere(self, value: Sphere) -> None: ...
    @property
    def SearchBoundingBox(self) -> BoundingBox: ...
    @SearchBoundingBox.setter
    def SearchBoundingBox(self, value: BoundingBox) -> None: ...


class RTree:
    def __init__(self): ...
    def CreateMeshFaceTree(mesh: Mesh) -> RTree: ...
    def CreatePointCloudTree(cloud: PointCloud) -> RTree: ...
    def CreateFromPointArray(points: Iterable[Point3d]) -> RTree: ...
    @overload
    def Insert(self, point: Point3d, elementId: int) -> bool: ...
    @overload
    def Insert(self, point: Point3d, elementId: IntPtr) -> bool: ...
    @overload
    def Insert(self, box: BoundingBox, elementId: int) -> bool: ...
    @overload
    def Insert(self, box: BoundingBox, elementId: IntPtr) -> bool: ...
    @overload
    def Insert(self, point: Point2d, elementId: int) -> bool: ...
    @overload
    def Insert(self, point: Point2d, elementId: IntPtr) -> bool: ...
    @overload
    def Remove(self, point: Point3d, elementId: int) -> bool: ...
    @overload
    def Remove(self, point: Point3d, elementId: IntPtr) -> bool: ...
    @overload
    def Remove(self, box: BoundingBox, elementId: int) -> bool: ...
    @overload
    def Remove(self, box: BoundingBox, elementId: IntPtr) -> bool: ...
    @overload
    def Remove(self, point: Point2d, elementId: int) -> bool: ...
    def Clear(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @overload
    def Search(self, box: BoundingBox, callback: EventHandler) -> bool: ...
    @overload
    def Search(self, box: BoundingBox, callback: EventHandler, tag: Object) -> bool: ...
    @overload
    def Search(self, sphere: Sphere, callback: EventHandler) -> bool: ...
    @overload
    def Search(self, sphere: Sphere, callback: EventHandler, tag: Object) -> bool: ...
    def SearchOverlaps(treeA: RTree, treeB: RTree, tolerance: float, callback: EventHandler) -> bool: ...
    def Dispose(self) -> None: ...
    def PointCloudClosestPoints(pointcloud: PointCloud, needlePts: Iterable[Point3d], limitDistance: float) -> Iterable[Set(int)]: ...
    def Point3dClosestPoints(hayPoints: Iterable[Point3d], needlePts: Iterable[Point3d], limitDistance: float) -> Iterable[Set(int)]: ...
    def PointCloudKNeighbors(pointcloud: PointCloud, needlePts: Iterable[Point3d], amount: int) -> Iterable[Set(int)]: ...
    def Point3dKNeighbors(hayPoints: Iterable[Point3d], needlePts: Iterable[Point3d], amount: int) -> Iterable[Set(int)]: ...


class SubDComponent:
    @property
    def Id(self) -> UInt32: ...
    @property
    def ParentSubD(self) -> SubD: ...


class SubDFace(SubDComponent):
    @property
    def EdgeCount(self) -> int: ...
    @property
    def VertexCount(self) -> int: ...
    @property
    def LimitSurfaceCenterPoint(self) -> Point3d: ...
    def EdgeAt(self, index: int) -> SubDEdge: ...
    def EdgeDirectionMatchesFaceOrientation(self, index: int) -> bool: ...
    def VertexAt(self, index: int) -> SubDVertex: ...


class SubDVertex(SubDComponent):
    @property
    def ControlNetPoint(self) -> Point3d: ...
    @ControlNetPoint.setter
    def ControlNetPoint(self, value: Point3d) -> None: ...
    @property
    def EdgeCount(self) -> int: ...
    @property
    def FaceCount(self) -> int: ...
    @property
    def Next(self) -> SubDVertex: ...
    @property
    def Previous(self) -> SubDVertex: ...
    def EdgeAt(self, index: int) -> SubDEdge: ...
    @property
    def Edges(self) -> Iterable[SubDEdge]: ...


class SubDEdge(SubDComponent):
    @property
    def FaceCount(self) -> int: ...
    @property
    def ControlNetLine(self) -> Line: ...
    @property
    def VertexFrom(self) -> SubDVertex: ...
    @property
    def VertexTo(self) -> SubDVertex: ...
    @property
    def Tag(self) -> SubDEdgeTag: ...
    @Tag.setter
    def Tag(self, value: SubDEdgeTag) -> None: ...
    def FaceAt(self, index: int) -> SubDFace: ...
    def ToNurbsCurve(self, clampEnds: bool) -> NurbsCurve: ...


class SumSurface(Surface):
    def Create(curveA: Curve, curveB: Curve) -> SumSurface: ...


class IsoStatus:
    #None = 0
    X = 1
    Y = 2
    West = 3
    South = 4
    East = 5
    North = 6


class SurfaceCurvature:
    @property
    def UVPoint(self) -> Point2d: ...
    @property
    def Point(self) -> Point3d: ...
    @property
    def Normal(self) -> Vector3d: ...
    def Direction(self, direction: int) -> Vector3d: ...
    def Kappa(self, direction: int) -> float: ...
    @property
    def Gaussian(self) -> float: ...
    @property
    def Mean(self) -> float: ...
    def OsculatingCircle(self, direction: int) -> Circle: ...


class Surface(GeometryBase):
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> Tuple[bool, float, float]: ...
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> Tuple[bool, float, float]: ...
    @property
    def IsSolid(self) -> bool: ...
    def Domain(self, direction: int) -> Interval: ...
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    def Degree(self, direction: int) -> int: ...
    def SpanCount(self, direction: int) -> int: ...
    def GetSpanVector(self, direction: int) -> Set(float): ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    @overload
    def Transpose(self) -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    def PointAt(self, u: float, v: float) -> Point3d: ...
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    def FrameAt(self, u: float, v: float) -> Tuple[bool, Plane]: ...
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    def IsClosed(self, direction: int) -> bool: ...
    def IsPeriodic(self, direction: int) -> bool: ...
    def IsSingular(self, side: int) -> bool: ...
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    def IsAtSeam(self, u: float, v: float) -> int: ...
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> Tuple[bool, Point3d, Set(Vector3d)]: ...
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    def Split(self, direction: int, parameter: float) -> Set(Surface): ...
    def ToBrep(self) -> Brep: ...
    def HasNurbsForm(self) -> int: ...
    @overload
    def ToNurbsSurface(self) -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> Tuple[NurbsSurface, int]: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def IsSphere(self) -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def TryGetSphere(self) -> Tuple[bool, Sphere]: ...
    @overload
    def TryGetSphere(self, tolerance: float) -> Tuple[bool, Sphere]: ...
    @overload
    def IsCylinder(self) -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def TryGetCylinder(self) -> Tuple[bool, Cylinder]: ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    def TryGetFiniteCylinder(self, tolerance: float) -> Tuple[bool, Cylinder]: ...
    @overload
    def IsCone(self) -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    @overload
    def TryGetCone(self) -> Tuple[bool, Cone]: ...
    @overload
    def TryGetCone(self, tolerance: float) -> Tuple[bool, Cone]: ...
    @overload
    def IsTorus(self) -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    @overload
    def TryGetTorus(self) -> Tuple[bool, Torus]: ...
    @overload
    def TryGetTorus(self, tolerance: float) -> Tuple[bool, Torus]: ...
    @overload
    def CreateRollingBallFillet(surfaceA: Surface, surfaceB: Surface, radius: float, tolerance: float) -> Set(Surface): ...
    @overload
    def CreateRollingBallFillet(surfaceA: Surface, flipA: bool, surfaceB: Surface, flipB: bool, radius: float, tolerance: float) -> Set(Surface): ...
    @overload
    def CreateRollingBallFillet(surfaceA: Surface, uvA: Point2d, surfaceB: Surface, uvB: Point2d, radius: float, tolerance: float) -> Set(Surface): ...
    def CreateExtrusion(profile: Curve, direction: Vector3d) -> Surface: ...
    def CreateExtrusionToPoint(profile: Curve, apexPoint: Point3d) -> Surface: ...
    @overload
    def CreatePeriodicSurface(surface: Surface, direction: int) -> Surface: ...
    @overload
    def CreatePeriodicSurface(surface: Surface, direction: int, bSmooth: bool) -> Surface: ...
    def CreateSoftEditSurface(surface: Surface, uv: Point2d, delta: Vector3d, uLength: float, vLength: float, tolerance: float, fixEnds: bool) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Point2d], interiorDistances: Iterable[float], tolerance: float) -> Surface: ...
    def GetSurfaceSize(self) -> Tuple[bool, float, float]: ...
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> Tuple[bool, float, float]: ...
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Iterable[Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    def InterpolatedCurveOnSurface(self, points: Iterable[Point3d], tolerance: float) -> NurbsCurve: ...
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...


class SurfaceProxy(Surface):


class TextRunType:
    #None = 0
    Text = 1
    Newline = 2
    Paragraph = 3
    Column = 4
    Field = 5
    Fontdef = 6
    Header = 7


class TextEntity(AnnotationBase):
    def __init__(self): ...
    def Create(text: str, plane: Plane, style: DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> TextEntity: ...
    def CreateWithRichText(richTextString: str, plane: Plane, style: DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> TextEntity: ...
    @property
    def Justification(self) -> TextJustification: ...
    @Justification.setter
    def Justification(self, value: TextJustification) -> None: ...
    @property
    def TextHorizontalAlignment(self) -> TextHorizontalAlignment: ...
    @TextHorizontalAlignment.setter
    def TextHorizontalAlignment(self, value: TextHorizontalAlignment) -> None: ...
    @property
    def TextVerticalAlignment(self) -> TextVerticalAlignment: ...
    @TextVerticalAlignment.setter
    def TextVerticalAlignment(self, value: TextVerticalAlignment) -> None: ...
    @property
    def TextOrientation(self) -> TextOrientation: ...
    @TextOrientation.setter
    def TextOrientation(self, value: TextOrientation) -> None: ...
    @overload
    def Transform(self, transform: Transform, style: DimensionStyle) -> bool: ...
    def GetTextTransform(self, textscale: float, dimstyle: DimensionStyle) -> Transform: ...
    def Explode(self) -> Set(Curve): ...
    def CreateSurfaces(self, dimstyle: DimensionStyle, smallCapsScale: float, spacing: float) -> Set(Brep): ...
    def CreatePolySurfaces(self, dimstyle: DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> Set(Brep): ...
    def CreateExtrusions(self, dimstyle: DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> Set(Extrusion): ...
    def CreateCurves(self, dimstyle: DimensionStyle, bAllowOpen: bool, smallCapsScale: float, spacing: float) -> Set(Curve): ...


class DistancingMode:
    Undefined = 0
    Linear = 1
    LinearFromEnd = 2
    Ratio = 3
    RatioFromEnd = 4


class MeshExtruder:
    def __init__(self, inputMesh: Mesh, componentIndices: Iterable[ComponentIndex]): ...
    def Dispose(self) -> None: ...
    @property
    def PreviewLines(self) -> Set(Line): ...
    @overload
    def ExtrudedMesh(self) -> Tuple[bool, Mesh]: ...
    @overload
    def ExtrudedMesh(self) -> Tuple[bool, Mesh, List]: ...
    def GetWallFaces(self) -> List: ...
    @property
    def Transform(self) -> Transform: ...
    @Transform.setter
    def Transform(self, value: Transform) -> None: ...
    @property
    def UVN(self) -> bool: ...
    @UVN.setter
    def UVN(self, value: bool) -> None: ...
    @property
    def EdgeBasedUVN(self) -> bool: ...
    @EdgeBasedUVN.setter
    def EdgeBasedUVN(self, value: bool) -> None: ...
    @property
    def KeepOriginalFaces(self) -> bool: ...
    @KeepOriginalFaces.setter
    def KeepOriginalFaces(self, value: bool) -> None: ...
    @property
    def TextureCoordinateMode(self) -> MeshExtruderParameterMode: ...
    @TextureCoordinateMode.setter
    def TextureCoordinateMode(self, value: MeshExtruderParameterMode) -> None: ...
    @property
    def SurfaceParameterMode(self) -> MeshExtruderParameterMode: ...
    @SurfaceParameterMode.setter
    def SurfaceParameterMode(self, value: MeshExtruderParameterMode) -> None: ...
    @property
    def FaceDirectionMode(self) -> MeshExtruderFaceDirectionMode: ...
    @FaceDirectionMode.setter
    def FaceDirectionMode(self, value: MeshExtruderFaceDirectionMode) -> None: ...


class Interpolator:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initialCapacity: int): ...
    @overload
    def __init__(self, list: RhinoList): ...
    @overload
    def __init__(self, collection: Iterable[float]): ...
    @overload
    def __init__(self, amount: int, defaultValue: float): ...
    @property
    def Cyclical(self) -> bool: ...
    @Cyclical.setter
    def Cyclical(self, value: bool) -> None: ...
    def InterpolateNearestNeighbour(self, t: float) -> float: ...
    def InterpolateLinear(self, t: float) -> float: ...
    def InterpolateCosine(self, t: float) -> float: ...
    def InterpolateCubic(self, t: float) -> float: ...
    def InterpolateCatmullRom(self, t: float) -> float: ...


class Particle:
    def __init__(self): ...
    @property
    def ParentSystem(self) -> ParticleSystem: ...
    @property
    def Index(self) -> int: ...
    @property
    def Location(self) -> Point3d: ...
    @Location.setter
    def Location(self, value: Point3d) -> None: ...
    @property
    def Size(self) -> Single: ...
    @Size.setter
    def Size(self, value: Single) -> None: ...
    @property
    def Color(self) -> Color: ...
    @Color.setter
    def Color(self, value: Color) -> None: ...
    @property
    def DisplayBitmapIndex(self) -> int: ...
    @DisplayBitmapIndex.setter
    def DisplayBitmapIndex(self, value: int) -> None: ...
    def Update(self) -> None: ...


class ParticleSystem:
    def __init__(self): ...
    @property
    def DrawRequiresDepthSorting(self) -> bool: ...
    @DrawRequiresDepthSorting.setter
    def DrawRequiresDepthSorting(self, value: bool) -> None: ...
    @property
    def DisplaySizesInWorldUnits(self) -> bool: ...
    @DisplaySizesInWorldUnits.setter
    def DisplaySizesInWorldUnits(self, value: bool) -> None: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    def Add(self, particle: Particle) -> bool: ...
    def Remove(self, particle: Particle) -> None: ...
    def Clear(self) -> None: ...
    def Update(self) -> None: ...
    def GetEnumerator(self) -> IEnumerator: ...


class Arc:
    @overload
    def __init__(self, circle: Circle, angleRadians: float): ...
    @overload
    def __init__(self, circle: Circle, angleIntervalRadians: Interval): ...
    @overload
    def __init__(self, plane: Plane, radius: float, angleRadians: float): ...
    @overload
    def __init__(self, center: Point3d, radius: float, angleRadians: float): ...
    @overload
    def __init__(self, plane: Plane, center: Point3d, radius: float, angleRadians: float): ...
    @overload
    def __init__(self, startPoint: Point3d, pointOnInterior: Point3d, endPoint: Point3d): ...
    @overload
    def __init__(self, pointA: Point3d, tangentA: Vector3d, pointB: Point3d): ...
    @property
    def Unset() -> Arc: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsCircle(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @property
    def Radius(self) -> float: ...
    @Radius.setter
    def Radius(self, value: float) -> None: ...
    @property
    def Diameter(self) -> float: ...
    @Diameter.setter
    def Diameter(self, value: float) -> None: ...
    @property
    def Center(self) -> Point3d: ...
    @Center.setter
    def Center(self, value: Point3d) -> None: ...
    @property
    def Circumference(self) -> float: ...
    @property
    def Length(self) -> float: ...
    @property
    def StartPoint(self) -> Point3d: ...
    @property
    def MidPoint(self) -> Point3d: ...
    @property
    def EndPoint(self) -> Point3d: ...
    @property
    def AngleDomain(self) -> Interval: ...
    @AngleDomain.setter
    def AngleDomain(self, value: Interval) -> None: ...
    @property
    def StartAngle(self) -> float: ...
    @StartAngle.setter
    def StartAngle(self, value: float) -> None: ...
    @property
    def EndAngle(self) -> float: ...
    @EndAngle.setter
    def EndAngle(self, value: float) -> None: ...
    @property
    def Angle(self) -> float: ...
    @Angle.setter
    def Angle(self, value: float) -> None: ...
    @property
    def StartAngleDegrees(self) -> float: ...
    @StartAngleDegrees.setter
    def StartAngleDegrees(self, value: float) -> None: ...
    @property
    def EndAngleDegrees(self) -> float: ...
    @EndAngleDegrees.setter
    def EndAngleDegrees(self, value: float) -> None: ...
    @property
    def AngleDegrees(self) -> float: ...
    @AngleDegrees.setter
    def AngleDegrees(self, value: float) -> None: ...
    def Trim(self, domain: Interval) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, other: Arc) -> bool: ...
    def GetHashCode(self) -> int: ...
    def op_Equality(a: Arc, b: Arc) -> bool: ...
    def op_Inequality(a: Arc, b: Arc) -> bool: ...
    def BoundingBox(self) -> BoundingBox: ...
    def PointAt(self, t: float) -> Point3d: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    def Reverse(self) -> None: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    def EpsilonEquals(self, other: Arc, epsilon: float) -> bool: ...
    @overload
    def ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve: ...


class BoundingBox:
    @overload
    def __init__(self, min: Point3d, max: Point3d): ...
    @overload
    def __init__(self, minX: float, minY: float, minZ: float, maxX: float, maxY: float, maxZ: float): ...
    @overload
    def __init__(self, points: Iterable[Point3d]): ...
    @overload
    def __init__(self, points: Iterable[Point3d], xform: Transform): ...
    @property
    def Empty() -> BoundingBox: ...
    @property
    def Unset() -> BoundingBox: ...
    def ToString(self) -> str: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Min(self) -> Point3d: ...
    @Min.setter
    def Min(self, value: Point3d) -> None: ...
    @property
    def Max(self) -> Point3d: ...
    @Max.setter
    def Max(self, value: Point3d) -> None: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Area(self) -> float: ...
    @property
    def Volume(self) -> float: ...
    @property
    def Diagonal(self) -> Vector3d: ...
    def PointAt(self, tx: float, ty: float, tz: float) -> Point3d: ...
    @overload
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, point: Point3d, includeInterior: bool) -> Point3d: ...
    def FurthestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def Inflate(self, amount: float) -> None: ...
    @overload
    def Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None: ...
    @overload
    def Contains(self, point: Point3d) -> bool: ...
    @overload
    def Contains(self, point: Point3d, strict: bool) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox, strict: bool) -> bool: ...
    def MakeValid(self) -> bool: ...
    def Corner(self, minX: bool, minY: bool, minZ: bool) -> Point3d: ...
    def IsDegenerate(self, tolerance: float) -> int: ...
    def GetCorners(self) -> Set(Point3d): ...
    def GetEdges(self) -> Set(Line): ...
    def Transform(self, xform: Transform) -> bool: ...
    def ToBrep(self) -> Brep: ...
    @overload
    def Union(self, other: BoundingBox) -> None: ...
    @overload
    def Union(self, point: Point3d) -> None: ...
    @overload
    def Union(a: BoundingBox, b: BoundingBox) -> BoundingBox: ...
    def Intersection(a: BoundingBox, b: BoundingBox) -> BoundingBox: ...
    @overload
    def Union(box: BoundingBox, point: Point3d) -> BoundingBox: ...


class Circle:
    @overload
    def __init__(self, radius: float): ...
    @overload
    def __init__(self, plane: Plane, radius: float): ...
    @overload
    def __init__(self, center: Point3d, radius: float): ...
    @overload
    def __init__(self, arc: Arc): ...
    @overload
    def __init__(self, point1: Point3d, point2: Point3d, point3: Point3d): ...
    @overload
    def __init__(self, plane: Plane, center: Point3d, radius: float): ...
    @overload
    def __init__(self, startPoint: Point3d, tangentAtP: Vector3d, pointOnCircle: Point3d): ...
    def TryFitCircleTT(c1: Curve, c2: Curve, t1: float, t2: float) -> Circle: ...
    def TryFitCircleTTT(c1: Curve, c2: Curve, c3: Curve, t1: float, t2: float, t3: float) -> Circle: ...
    @property
    def Unset() -> Circle: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Radius(self) -> float: ...
    @Radius.setter
    def Radius(self, value: float) -> None: ...
    @property
    def Diameter(self) -> float: ...
    @Diameter.setter
    def Diameter(self, value: float) -> None: ...
    @property
    def Plane(self) -> Plane: ...
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @property
    def Center(self) -> Point3d: ...
    @Center.setter
    def Center(self, value: Point3d) -> None: ...
    @property
    def Normal(self) -> Vector3d: ...
    @property
    def Circumference(self) -> float: ...
    @Circumference.setter
    def Circumference(self, value: float) -> None: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    def IsInPlane(self, plane: Plane, tolerance: float) -> bool: ...
    def PointAt(self, t: float) -> Point3d: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    def DerivativeAt(self, derivative: int, t: float) -> Vector3d: ...
    def ClosestParameter(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d, point: Point3d) -> bool: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d, point: Point3d) -> bool: ...
    def Translate(self, delta: Vector3d) -> bool: ...
    def Reverse(self) -> None: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve: ...
    def TryFitCircleToPoints(points: Iterable[Point3d]) -> Tuple[bool, Circle]: ...
    def EpsilonEquals(self, other: Circle, epsilon: float) -> bool: ...


class Cone:
    def __init__(self, plane: Plane, height: float, radius: float): ...
    @property
    def Unset() -> Cone: ...
    @property
    def Plane(self) -> Plane: ...
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @property
    def Height(self) -> float: ...
    @Height.setter
    def Height(self, value: float) -> None: ...
    @property
    def Radius(self) -> float: ...
    @Radius.setter
    def Radius(self, value: float) -> None: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def BasePoint(self) -> Point3d: ...
    @property
    def ApexPoint(self) -> Point3d: ...
    @property
    def Axis(self) -> Vector3d: ...
    def AngleInRadians(self) -> float: ...
    def AngleInDegrees(self) -> float: ...
    def ToNurbsSurface(self) -> NurbsSurface: ...
    def ToRevSurface(self) -> RevSurface: ...
    def ToBrep(self, capBottom: bool) -> Brep: ...
    def EpsilonEquals(self, other: Cone, epsilon: float) -> bool: ...


class BlendContinuity:
    Position = 0
    Tangency = 1
    Curvature = 2


class CurveOffsetCornerStyle:
    #None = 0
    Sharp = 1
    Round = 2
    Smooth = 3
    Chamfer = 4


class CurveKnotStyle:
    Uniform = 0
    Chord = 1
    ChordSquareRoot = 2
    UniformPeriodic = 3
    ChordPeriodic = 4
    ChordSquareRootPeriodic = 5


class CurveOrientation:
    Undefined = 0
    CounterClockwise = 1
    Clockwise = -1


class PointContainment:
    Unset = 0
    Inside = 1
    Outside = 2
    Coincident = 3


class RegionContainment:
    Disjoint = 0
    MutualIntersection = 1
    AInsideB = 2
    BInsideA = 3


class CurveExtensionStyle:
    Line = 0
    Arc = 1
    Smooth = 2


class CurveSimplifyOptions:
    #None = 0
    SplitAtFullyMultipleKnots = 1
    RebuildLines = 2
    RebuildArcs = 4
    RebuildRationals = 8
    AdjustG1 = 16
    Merge = 32
    All = 63


class CurveEnd:
    #None = 0
    Start = 1
    End = 2
    Both = 3


class CurveEvaluationSide:
    Default = 0
    Above = 1
    Below = -1


class ConicSectionType:
    Unknown = 0
    Circle = 1
    Ellipse = 2
    Hyperbola = 3
    Parabola = 4


class Curve(GeometryBase):
    def DivideEquidistant(self, distance: float) -> Set(Point3d): ...
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> Set(Point3d): ...
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> Tuple[bool, float]: ...
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> Tuple[bool, float]: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def Split(self, t: float) -> Set(Curve): ...
    @overload
    def Split(self, t: Iterable[float]) -> Set(Curve): ...
    @overload
    def Split(self, cutter: Brep, tolerance: float) -> Set(Curve): ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> Set(Curve): ...
    @overload
    def Split(self, cutter: Surface, tolerance: float) -> Set(Curve): ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> Set(Curve): ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Iterable[GeometryBase]) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    def ExtendByLine(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    def ExtendByArc(self, side: CurveEnd, geometry: Iterable[GeometryBase]) -> Curve: ...
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    def HasNurbsForm(self) -> int: ...
    @overload
    def ToNurbsCurve(self) -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Set(Curve): ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> Set(Curve): ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Set(Curve), Set(Surface)]: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Tuple[Curve, Set(float), Set(float)]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> Set(Curve): ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> Set(Curve): ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: Set(float), offsetDistances: Set(float), fittingTolerance: float) -> Set(Curve): ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> Set(Curve): ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> Set(Curve): ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: Set(float), offsetDistances: Set(float), fittingTolerance: float) -> Set(Curve): ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> Set(Curve): ...
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def IsCircle(self) -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def TryGetCircle(self) -> Tuple[bool, Circle]: ...
    @overload
    def TryGetCircle(self, tolerance: float) -> Tuple[bool, Circle]: ...
    @overload
    def IsEllipse(self) -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def TryGetEllipse(self) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> Tuple[bool, Ellipse]: ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> Tuple[bool, Ellipse]: ...
    @overload
    def IsPlanar(self) -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...
    @overload
    def TryGetPlane(self, tolerance: float) -> Tuple[bool, Plane]: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsPeriodic(self) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    def InflectionPoints(self) -> Set(Point3d): ...
    def MaxCurvaturePoints(self) -> Set(Point3d): ...
    def MakeClosed(self, tolerance: float) -> bool: ...
    @overload
    def ClosedCurveOrientation(self) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    def Reverse(self) -> bool: ...
    def LcoalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> Tuple[bool, float]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase], maximumDistance: float) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, geometry: Iterable[GeometryBase]) -> Tuple[bool, Point3d, Point3d, int]: ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> Tuple[bool, Point3d, Point3d]: ...
    @overload
    def Contains(self, testPoint: Point3d) -> PointContainment: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane) -> PointContainment: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    def ExtremeParameters(self, direction: Vector3d) -> Set(float): ...
    @overload
    def CreatePeriodicCurve(curve: Curve) -> Curve: ...
    @overload
    def CreatePeriodicCurve(curve: Curve, smooth: bool) -> Curve: ...
    def PointAt(self, t: float) -> Point3d: ...
    @property
    def PointAtStart(self) -> Point3d: ...
    @property
    def PointAtEnd(self) -> Point3d: ...
    def PointAtLength(self, length: float) -> Point3d: ...
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    def SetStartPoint(self, point: Point3d) -> bool: ...
    def SetEndPoint(self, point: Point3d) -> bool: ...
    def TangentAt(self, t: float) -> Vector3d: ...
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    def FrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> Set(Vector3d): ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> Set(Vector3d): ...
    def CurvatureAt(self, t: float) -> Vector3d: ...
    def PerpendicularFrameAt(self, t: float) -> Tuple[bool, Plane]: ...
    def GetPerpendicularFrames(self, parameters: Iterable[float]) -> Set(Plane): ...
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> Tuple[bool, float]: ...
    @overload
    def GetLength(self) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def LengthParameter(self, segmentLength: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def NormalizedLengthParameters(self, s: Set(float), absoluteTolerance: float) -> Set(float): ...
    @overload
    def NormalizedLengthParameters(self, s: Set(float), absoluteTolerance: float, fractionalTolerance: float) -> Set(float): ...
    @overload
    def NormalizedLengthParameters(self, s: Set(float), absoluteTolerance: float, subdomain: Interval) -> Set(float): ...
    @overload
    def NormalizedLengthParameters(self, s: Set(float), absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> Set(float): ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Set(float): ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> Tuple[Set(float), Set(Point3d)]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Set(float): ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Set(float): ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> Tuple[Set(float), Set(Point3d)]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> Tuple[Set(float), Set(Point3d)]: ...
    @overload
    def GetConicSectionType(self) -> ConicSectionType: ...
    @overload
    def GetConicSectionType(self) -> Tuple[ConicSectionType, Point3d, Point3d, Point3d]: ...
    @overload
    def CreateInterpolatedCurve(points: Iterable[Point3d], degree: int) -> Curve: ...
    @overload
    def CreateInterpolatedCurve(points: Iterable[Point3d], degree: int, knots: CurveKnotStyle) -> Curve: ...
    @overload
    def CreateInterpolatedCurve(points: Iterable[Point3d], degree: int, knots: CurveKnotStyle, startTangent: Vector3d, endTangent: Vector3d) -> Curve: ...
    def CreateSoftEditCurve(curve: Curve, t: float, delta: Vector3d, length: float, fixEnds: bool) -> Curve: ...
    def CreateFilletCornersCurve(curve: Curve, radius: float, tolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    def CreateControlPointCurve(points: Iterable[Point3d], degree: int) -> Curve: ...
    @overload
    def CreateControlPointCurve(points: Iterable[Point3d]) -> Curve: ...
    def CreateArcBlend(startPt: Point3d, startDir: Vector3d, endPt: Point3d, endDir: Vector3d, controlPointLengthRatio: float) -> Curve: ...
    @overload
    def CreateMeanCurve(curveA: Curve, curveB: Curve, angleToleranceRadians: float) -> Curve: ...
    @overload
    def CreateMeanCurve(curveA: Curve, curveB: Curve) -> Curve: ...
    @overload
    def CreateBlendCurve(curveA: Curve, curveB: Curve, continuity: BlendContinuity) -> Curve: ...
    @overload
    def CreateBlendCurve(curveA: Curve, curveB: Curve, continuity: BlendContinuity, bulgeA: float, bulgeB: float) -> Curve: ...
    @overload
    def CreateBlendCurve(curve0: Curve, t0: float, reverse0: bool, continuity0: BlendContinuity, curve1: Curve, t1: float, reverse1: bool, continuity1: BlendContinuity) -> Curve: ...
    @overload
    def CreateTweenCurves(curve0: Curve, curve1: Curve, numCurves: int) -> Set(Curve): ...
    @overload
    def CreateTweenCurves(curve0: Curve, curve1: Curve, numCurves: int, tolerance: float) -> Set(Curve): ...
    @overload
    def CreateTweenCurvesWithMatching(curve0: Curve, curve1: Curve, numCurves: int) -> Set(Curve): ...
    @overload
    def CreateTweenCurvesWithMatching(curve0: Curve, curve1: Curve, numCurves: int, tolerance: float) -> Set(Curve): ...
    @overload
    def CreateTweenCurvesWithSampling(curve0: Curve, curve1: Curve, numCurves: int, numSamples: int) -> Set(Curve): ...
    @overload
    def CreateTweenCurvesWithSampling(curve0: Curve, curve1: Curve, numCurves: int, numSamples: int, tolerance: float) -> Set(Curve): ...
    @overload
    def JoinCurves(inputCurves: Iterable[Curve]) -> Set(Curve): ...
    @overload
    def JoinCurves(inputCurves: Iterable[Curve], joinTolerance: float) -> Set(Curve): ...
    @overload
    def JoinCurves(inputCurves: Iterable[Curve], joinTolerance: float, preserveDirection: bool) -> Set(Curve): ...
    def MakeEndsMeet(curveA: Curve, adjustStartCurveA: bool, curveB: Curve, adjustStartCurveB: bool) -> bool: ...
    def GetFilletPoints(curve0: Curve, curve1: Curve, radius: float, t0Base: float, t1Base: float) -> Tuple[bool, float, float, Plane]: ...
    def CreateFillet(curve0: Curve, curve1: Curve, radius: float, t0Base: float, t1Base: float) -> Arc: ...
    def CreateFilletCurves(curve0: Curve, point0: Point3d, curve1: Curve, point1: Point3d, radius: float, join: bool, trim: bool, arcExtension: bool, tolerance: float, angleTolerance: float) -> Set(Curve): ...
    @overload
    def CreateBooleanUnion(curves: Iterable[Curve]) -> Set(Curve): ...
    @overload
    def CreateBooleanUnion(curves: Iterable[Curve], tolerance: float) -> Set(Curve): ...
    @overload
    def CreateBooleanIntersection(curveA: Curve, curveB: Curve) -> Set(Curve): ...
    @overload
    def CreateBooleanIntersection(curveA: Curve, curveB: Curve, tolerance: float) -> Set(Curve): ...
    @overload
    def CreateBooleanDifference(curveA: Curve, curveB: Curve) -> Set(Curve): ...
    @overload
    def CreateBooleanDifference(curveA: Curve, curveB: Curve, tolerance: float) -> Set(Curve): ...
    @overload
    def CreateBooleanDifference(curveA: Curve, subtractors: Iterable[Curve]) -> Set(Curve): ...
    @overload
    def CreateBooleanDifference(curveA: Curve, subtractors: Iterable[Curve], tolerance: float) -> Set(Curve): ...
    def CreateTextOutlines(text: str, font: str, textHeight: float, textStyle: int, closeLoops: bool, plane: Plane, smallCapsScale: float, tolerance: float) -> Set(Curve): ...
    def CreateCurve2View(curveA: Curve, curveB: Curve, vectorA: Vector3d, vectorB: Vector3d, tolerance: float, angleTolerance: float) -> Set(Curve): ...
    def DoDirectionsMatch(curveA: Curve, curveB: Curve) -> bool: ...
    @overload
    def ProjectToMesh(curve: Curve, mesh: Mesh, direction: Vector3d, tolerance: float) -> Set(Curve): ...
    @overload
    def ProjectToMesh(curve: Curve, meshes: Iterable[Mesh], direction: Vector3d, tolerance: float) -> Set(Curve): ...
    @overload
    def ProjectToMesh(curves: Iterable[Curve], meshes: Iterable[Mesh], direction: Vector3d, tolerance: float) -> Set(Curve): ...
    @overload
    def ProjectToBrep(curve: Curve, brep: Brep, direction: Vector3d, tolerance: float) -> Set(Curve): ...
    @overload
    def ProjectToBrep(curve: Curve, breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Set(Curve): ...
    @overload
    def ProjectToBrep(curve: Curve, breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Tuple[Set(Curve), Set(int)]: ...
    @overload
    def ProjectToBrep(curves: Iterable[Curve], breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Set(Curve): ...
    @overload
    def ProjectToBrep(curves: Iterable[Curve], breps: Iterable[Brep], direction: Vector3d, tolerance: float) -> Tuple[Set(Curve), Set(int), Set(int)]: ...
    def ProjectToPlane(curve: Curve, plane: Plane) -> Curve: ...
    @overload
    def PullToBrepFace(curve: Curve, face: BrepFace, tolerance: float) -> Set(Curve): ...
    def GetDistancesBetweenCurves(curveA: Curve, curveB: Curve, tolerance: float) -> Tuple[bool, float, float, float, float, float, float]: ...
    def PlanarClosedCurveRelationship(curveA: Curve, curveB: Curve, testPlane: Plane, tolerance: float) -> RegionContainment: ...
    def PlanarCurveCollision(curveA: Curve, curveB: Curve, testPlane: Plane, tolerance: float) -> bool: ...
    def Duplicate(self) -> GeometryBase: ...
    def DuplicateCurve(self) -> Curve: ...
    def DuplicateSegments(self) -> Set(Curve): ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> Tuple[bool, float]: ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> Tuple[bool, float]: ...
    @property
    def Domain(self) -> Interval: ...
    @Domain.setter
    def Domain(self, value: Interval) -> None: ...
    @property
    def Dimension(self) -> int: ...
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @property
    def SpanCount(self) -> int: ...
    @property
    def Degree(self) -> int: ...
    @overload
    def IsLinear(self) -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    def IsPolyline(self) -> bool: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline]: ...
    @overload
    def TryGetPolyline(self) -> Tuple[bool, Polyline, Set(float)]: ...
    @overload
    def IsArc(self) -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def TryGetArc(self) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, tolerance: float) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane) -> Tuple[bool, Arc]: ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> Tuple[bool, Arc]: ...


class Cylinder:
    @overload
    def __init__(self, baseCircle: Circle): ...
    @overload
    def __init__(self, baseCircle: Circle, height: float): ...
    @property
    def Unset() -> Cylinder: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsFinite(self) -> bool: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Axis(self) -> Vector3d: ...
    @property
    def TotalHeight(self) -> float: ...
    @property
    def Height1(self) -> float: ...
    @Height1.setter
    def Height1(self, value: float) -> None: ...
    @property
    def Height2(self) -> float: ...
    @Height2.setter
    def Height2(self, value: float) -> None: ...
    @property
    def Radius(self) -> float: ...
    @Radius.setter
    def Radius(self, value: float) -> None: ...
    @property
    def BasePlane(self) -> Plane: ...
    @BasePlane.setter
    def BasePlane(self, value: Plane) -> None: ...
    def CircleAt(self, linearParameter: float) -> Circle: ...
    def LineAt(self, angularParameter: float) -> Line: ...
    def ToBrep(self, capBottom: bool, capTop: bool) -> Brep: ...
    def ToNurbsSurface(self) -> NurbsSurface: ...
    def ToRevSurface(self) -> RevSurface: ...
    def EpsilonEquals(self, other: Cylinder, epsilon: float) -> bool: ...


class Ellipse:
    @overload
    def __init__(self, plane: Plane, radius1: float, radius2: float): ...
    @overload
    def __init__(self, center: Point3d, second: Point3d, third: Point3d): ...
    @property
    def Plane(self) -> Plane: ...
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @property
    def Radius1(self) -> float: ...
    @Radius1.setter
    def Radius1(self, value: float) -> None: ...
    @property
    def Radius2(self) -> float: ...
    @Radius2.setter
    def Radius2(self, value: float) -> None: ...
    @property
    def IsValid(self) -> bool: ...
    def ToNurbsCurve(self) -> NurbsCurve: ...
    def EpsilonEquals(self, other: Ellipse, epsilon: float) -> bool: ...


class GeometryBase(CommonObject):
    @property
    def IsDocumentControlled(self) -> bool: ...
    def DuplicateShallow(self) -> GeometryBase: ...
    def Duplicate(self) -> GeometryBase: ...
    @property
    def ObjectType(self) -> ObjectType: ...
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...
    def Scale(self, scaleFactor: float) -> bool: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    def MemoryEstimate(self) -> UInt32: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> Tuple[BoundingBox, Box]: ...
    @property
    def IsDeformable(self) -> bool: ...
    def MakeDeformable(self) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    def ComponentIndex(self) -> ComponentIndex: ...
    def SetUserString(self, key: str, value: str) -> bool: ...
    def GetUserString(self, key: str) -> str: ...
    @property
    def UserStringCount(self) -> int: ...
    def GetUserStrings(self) -> NameValueCollection: ...
    def GeometryEquals(first: GeometryBase, second: GeometryBase) -> bool: ...


class Line:
    @overload
    def __init__(self, from_: Point3d, to: Point3d): ...
    @overload
    def __init__(self, start: Point3d, span: Vector3d): ...
    @overload
    def __init__(self, start: Point3d, direction: Vector3d, length: float): ...
    @overload
    def __init__(self, x0: float, y0: float, z0: float, x1: float, y1: float, z1: float): ...
    @property
    def From(self) -> Point3d: ...
    @From.setter
    def From(self, value: Point3d) -> None: ...
    @property
    def FromX(self) -> float: ...
    @FromX.setter
    def FromX(self, value: float) -> None: ...
    @property
    def FromY(self) -> float: ...
    @FromY.setter
    def FromY(self, value: float) -> None: ...
    @property
    def FromZ(self) -> float: ...
    @FromZ.setter
    def FromZ(self, value: float) -> None: ...
    @property
    def To(self) -> Point3d: ...
    @To.setter
    def To(self, value: Point3d) -> None: ...
    @property
    def ToX(self) -> float: ...
    @ToX.setter
    def ToX(self, value: float) -> None: ...
    @property
    def ToY(self) -> float: ...
    @ToY.setter
    def ToY(self, value: float) -> None: ...
    @property
    def ToZ(self) -> float: ...
    @ToZ.setter
    def ToZ(self, value: float) -> None: ...
    @property
    def Unset() -> Line: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Length(self) -> float: ...
    @Length.setter
    def Length(self, value: float) -> None: ...
    @property
    def Direction(self) -> Vector3d: ...
    @property
    def UnitTangent(self) -> Vector3d: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    def TryFitLineToPoints(points: Iterable[Point3d]) -> Tuple[bool, Line]: ...
    def TryCreateBetweenCurves(curve0: Curve, curve1: Curve, t0: float, t1: float, perpendicular0: bool, perpendicular1: bool) -> Tuple[bool, float, float, Line]: ...
    def op_Equality(a: Line, b: Line) -> bool: ...
    def op_Inequality(a: Line, b: Line) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, other: Line) -> bool: ...
    def EpsilonEquals(self, other: Line, epsilon: float) -> bool: ...
    def GetHashCode(self) -> int: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Flip(self) -> None: ...
    def PointAt(self, t: float) -> Point3d: ...
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    def ClosestPoint(self, testPoint: Point3d, limitToFiniteSegment: bool) -> Point3d: ...
    def DistanceTo(self, testPoint: Point3d, limitToFiniteSegment: bool) -> float: ...
    @overload
    def MinimumDistanceTo(self, testPoint: Point3d) -> float: ...
    @overload
    def MinimumDistanceTo(self, testLine: Line) -> float: ...
    @overload
    def MaximumDistanceTo(self, testPoint: Point3d) -> float: ...
    @overload
    def MaximumDistanceTo(self, testLine: Line) -> float: ...
    def Transform(self, xform: Transform) -> bool: ...
    def ToNurbsCurve(self) -> NurbsCurve: ...
    def PointAtLength(self, distance: float) -> Point3d: ...
    def Extend(self, startLength: float, endLength: float) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox, additionalLength: float) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: Box) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: Box, additionalLength: float) -> bool: ...
    def TryGetPlane(self) -> Tuple[bool, Plane]: ...


class NurbsCurve(Curve):
    @overload
    def __init__(self, other: NurbsCurve): ...
    @overload
    def __init__(self, degree: int, pointCount: int): ...
    @overload
    def __init__(self, dimension: int, rational: bool, order: int, pointCount: int): ...
    def CreateFromLine(line: Line) -> NurbsCurve: ...
    @overload
    def CreateFromArc(arc: Arc) -> NurbsCurve: ...
    def UVNDirectionsAt(self, t: float) -> Tuple[bool, Vector3d, Vector3d, Vector3d]: ...
    def MakeCompatible(curves: Iterable[Curve], startPt: Point3d, endPt: Point3d, simplifyMethod: int, numPoints: int, refitTolerance: float, angleTolerance: float) -> Set(NurbsCurve): ...
    def CreateParabolaFromVertex(vertex: Point3d, startPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...
    def CreateParabolaFromFocus(focus: Point3d, startPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...
    @overload
    def CreateFromArc(arc: Arc, degree: int, cvCount: int) -> NurbsCurve: ...
    @overload
    def CreateHSpline(points: Iterable[Point3d]) -> NurbsCurve: ...
    @overload
    def CreateHSpline(points: Iterable[Point3d], startTangent: Vector3d, endTangent: Vector3d) -> NurbsCurve: ...
    @overload
    def CreateFromCircle(circle: Circle) -> NurbsCurve: ...
    @overload
    def CreateFromCircle(circle: Circle, degree: int, cvCount: int) -> NurbsCurve: ...
    def CreateFromEllipse(ellipse: Ellipse) -> NurbsCurve: ...
    def IsDuplicate(curveA: NurbsCurve, curveB: NurbsCurve, ignoreParameterization: bool, tolerance: float) -> bool: ...
    def Create(periodic: bool, degree: int, points: Iterable[Point3d]) -> NurbsCurve: ...
    @property
    def Order(self) -> int: ...
    @property
    def IsRational(self) -> bool: ...
    @property
    def Knots(self) -> NurbsCurveKnotList: ...
    @property
    def Points(self) -> NurbsCurvePointList: ...
    @overload
    def SetEndCondition(self, bSetEnd: bool, continuity: NurbsCurveEndConditionType, point: Point3d, tangent: Vector3d) -> bool: ...
    @overload
    def SetEndCondition(self, bSetEnd: bool, continuity: NurbsCurveEndConditionType, point: Point3d, tangent: Vector3d, curvature: Vector3d) -> bool: ...
    def IncreaseDegree(self, desiredDegree: int) -> bool: ...
    @property
    def HasBezierSpans(self) -> bool: ...
    def MakePiecewiseBezier(self, setEndWeightsToOne: bool) -> bool: ...
    def Reparameterize(self, c: float) -> bool: ...
    def GrevilleParameter(self, index: int) -> float: ...
    def GrevillePoint(self, index: int) -> Point3d: ...
    def GrevilleParameters(self) -> Set(float): ...
    @overload
    def GrevillePoints(self) -> Point3dList: ...
    @overload
    def GrevillePoints(self, all: bool) -> Point3dList: ...
    def SetGrevillePoints(self, points: Iterable[Point3d]) -> bool: ...
    def EpsilonEquals(self, other: NurbsCurve, epsilon: float) -> bool: ...
    @overload
    def CreateSpiral(axisStart: Point3d, axisDir: Vector3d, radiusPoint: Point3d, pitch: float, turnCount: float, radius0: float, radius1: float) -> NurbsCurve: ...
    @overload
    def CreateSpiral(railCurve: Curve, t0: float, t1: float, radiusPoint: Point3d, pitch: float, turnCount: float, radius0: float, radius1: float, pointsPerTurn: int) -> NurbsCurve: ...


class ControlPoint:
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    def __init__(self, x: float, y: float, z: float, weight: float): ...
    @overload
    def __init__(self, pt: Point3d): ...
    @overload
    def __init__(self, euclideanPt: Point3d, weight: float): ...
    @overload
    def __init__(self, pt: Point4d): ...
    @property
    def Unset() -> ControlPoint: ...
    @property
    def Location(self) -> Point3d: ...
    @Location.setter
    def Location(self, value: Point3d) -> None: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> None: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> None: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> None: ...
    @property
    def Weight(self) -> float: ...
    @Weight.setter
    def Weight(self, value: float) -> None: ...
    def EpsilonEquals(self, other: ControlPoint, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: ControlPoint) -> bool: ...


class PlaneFitResult:
    Success = 0
    Inconclusive = 1
    Failure = -1


class Plane:
    @overload
    def __init__(self, other: Plane): ...
    @overload
    def __init__(self, origin: Point3d, normal: Vector3d): ...
    @overload
    def __init__(self, origin: Point3d, xDirection: Vector3d, yDirection: Vector3d): ...
    @overload
    def __init__(self, origin: Point3d, xPoint: Point3d, yPoint: Point3d): ...
    @overload
    def __init__(self, a: float, b: float, c: float, d: float): ...
    @property
    def Origin(self) -> Point3d: ...
    @Origin.setter
    def Origin(self, value: Point3d) -> None: ...
    @property
    def OriginX(self) -> float: ...
    @OriginX.setter
    def OriginX(self, value: float) -> None: ...
    @property
    def OriginY(self) -> float: ...
    @OriginY.setter
    def OriginY(self, value: float) -> None: ...
    @property
    def OriginZ(self) -> float: ...
    @OriginZ.setter
    def OriginZ(self, value: float) -> None: ...
    @property
    def XAxis(self) -> Vector3d: ...
    @XAxis.setter
    def XAxis(self, value: Vector3d) -> None: ...
    @property
    def YAxis(self) -> Vector3d: ...
    @YAxis.setter
    def YAxis(self, value: Vector3d) -> None: ...
    @property
    def ZAxis(self) -> Vector3d: ...
    @ZAxis.setter
    def ZAxis(self, value: Vector3d) -> None: ...
    @property
    def WorldXY() -> Plane: ...
    @property
    def WorldYZ() -> Plane: ...
    @property
    def WorldZX() -> Plane: ...
    @property
    def Unset() -> Plane: ...
    @overload
    def FitPlaneToPoints(points: Iterable[Point3d]) -> Tuple[PlaneFitResult, Plane]: ...
    @overload
    def FitPlaneToPoints(points: Iterable[Point3d]) -> Tuple[PlaneFitResult, Plane, float]: ...
    def op_Equality(a: Plane, b: Plane) -> bool: ...
    def op_Inequality(a: Plane, b: Plane) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, plane: Plane) -> bool: ...
    def GetHashCode(self) -> int: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @property
    def Normal(self) -> Vector3d: ...
    @property
    def IsValid(self) -> bool: ...
    def GetPlaneEquation(self) -> Set(float): ...
    def UpdateEquation(self) -> bool: ...
    def ValueAt(self, p: Point3d) -> float: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def PointAt(self, u: float, v: float, w: float) -> Point3d: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox) -> Tuple[bool, Interval, Interval]: ...
    @overload
    def ExtendThroughBox(self, box: Box) -> Tuple[bool, Interval, Interval]: ...
    def ClosestParameter(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def DistanceTo(self, testPoint: Point3d) -> float: ...
    @overload
    def DistanceTo(self, bbox: BoundingBox) -> Tuple[bool, float, float]: ...
    def RemapToPlaneSpace(self, ptSample: Point3d) -> Tuple[bool, Point3d]: ...
    def Flip(self) -> None: ...
    def Transform(self, xform: Transform) -> bool: ...
    def Translate(self, delta: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d, centerOfRotation: Point3d) -> bool: ...
    def EpsilonEquals(self, other: Plane, epsilon: float) -> bool: ...
    def Clone(self) -> Plane: ...


class Point2f:
    @overload
    def __init__(self, x: Single, y: Single): ...
    @overload
    def __init__(self, x: float, y: float): ...
    @property
    def Unset() -> Point2f: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def X(self) -> Single: ...
    @X.setter
    def X(self, value: Single) -> None: ...
    @property
    def Y(self) -> Single: ...
    @Y.setter
    def Y(self, value: Single) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, point: Point2f) -> bool: ...
    def EpsilonEquals(self, other: Point2f, epsilon: Single) -> bool: ...
    def CompareTo(self, other: Point2f) -> int: ...
    def GetHashCode(self) -> int: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @property
    def Item(self, index: int) -> Single: ...
    @Item.setter
    def Item(self, index: int, value: Single) -> None: ...
    def op_Equality(a: Point2f, b: Point2f) -> bool: ...
    def op_Inequality(a: Point2f, b: Point2f) -> bool: ...
    def op_LessThan(a: Point2f, b: Point2f) -> bool: ...
    def op_LessThanOrEqual(a: Point2f, b: Point2f) -> bool: ...
    def op_GreaterThan(a: Point2f, b: Point2f) -> bool: ...
    def op_GreaterThanOrEqual(a: Point2f, b: Point2f) -> bool: ...
    def op_Explicit(point: Point2d) -> Point2f: ...
    def op_Addition(a: Point2f, b: Point2f) -> Vector2f: ...
    def op_Subtraction(a: Point2f, b: Point2f) -> Vector2f: ...
    def op_Multiply(a: Point2f, b: Single) -> Point2f: ...
    def op_Division(a: Point2f, b: Single) -> Point2f: ...


class Point3f:
    def __init__(self, x: Single, y: Single, z: Single): ...
    @property
    def Origin() -> Point3f: ...
    @property
    def Unset() -> Point3f: ...
    @property
    def X(self) -> Single: ...
    @X.setter
    def X(self, value: Single) -> None: ...
    @property
    def Y(self) -> Single: ...
    @Y.setter
    def Y(self, value: Single) -> None: ...
    @property
    def Z(self) -> Single: ...
    @Z.setter
    def Z(self, value: Single) -> None: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, point: Point3f) -> bool: ...
    def EpsilonEquals(self, other: Point3f, epsilon: Single) -> bool: ...
    def CompareTo(self, other: Point3f) -> int: ...
    def GetHashCode(self) -> int: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @property
    def IsValid(self) -> bool: ...
    def DistanceTo(self, other: Point3f) -> float: ...
    def Transform(self, xform: Transform) -> None: ...
    def op_Equality(a: Point3f, b: Point3f) -> bool: ...
    def op_Inequality(a: Point3f, b: Point3f) -> bool: ...
    def op_LessThan(a: Point3f, b: Point3f) -> bool: ...
    def op_LessThanOrEqual(a: Point3f, b: Point3f) -> bool: ...
    def op_GreaterThan(a: Point3f, b: Point3f) -> bool: ...
    def op_GreaterThanOrEqual(a: Point3f, b: Point3f) -> bool: ...
    def op_Subtraction(point1: Point3f, point2: Point3f) -> Vector3f: ...
    def op_Addition(point1: Point3f, point2: Point3f) -> Point3f: ...
    def Subtract(point1: Point3f, point2: Point3f) -> Vector3f: ...
    def op_Explicit(point: Point3d) -> Point3f: ...
    @overload
    def op_Multiply(point: Point3f, value: Single) -> Point3f: ...
    @overload
    def op_Multiply(value: Single, point: Point3f) -> Point3f: ...


class Vector2f:
    def __init__(self, x: Single, y: Single): ...
    @property
    def X(self) -> Single: ...
    @X.setter
    def X(self, value: Single) -> None: ...
    @property
    def Y(self) -> Single: ...
    @Y.setter
    def Y(self, value: Single) -> None: ...
    @property
    def SquareLength(self) -> Single: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, vector: Vector2f) -> bool: ...
    def EpsilonEquals(self, other: Vector2f, epsilon: Single) -> bool: ...
    def CompareTo(self, other: Vector2f) -> int: ...
    @property
    def IsValid(self) -> bool: ...
    def GetHashCode(self) -> int: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def op_Equality(a: Vector2f, b: Vector2f) -> bool: ...
    def op_Inequality(a: Vector2f, b: Vector2f) -> bool: ...
    def op_LessThan(a: Vector2f, b: Vector2f) -> bool: ...
    def op_LessThanOrEqual(a: Vector2f, b: Vector2f) -> bool: ...
    def op_GreaterThan(a: Vector2f, b: Vector2f) -> bool: ...
    def op_GreaterThanOrEqual(a: Vector2f, b: Vector2f) -> bool: ...
    def op_Multiply(point1: Vector2f, point2: Vector2f) -> float: ...
    def Multiply(point1: Vector2f, point2: Vector2f) -> float: ...
    def op_Subtraction(a: Vector2f, b: Vector2f) -> Vector2f: ...
    def op_Addition(a: Vector2f, b: Vector2f) -> Vector2f: ...


class Vector3f:
    def __init__(self, x: Single, y: Single, z: Single): ...
    @property
    def Zero() -> Vector3f: ...
    @property
    def XAxis() -> Vector3f: ...
    @property
    def YAxis() -> Vector3f: ...
    @property
    def ZAxis() -> Vector3f: ...
    @property
    def Unset() -> Vector3f: ...
    @property
    def X(self) -> Single: ...
    @X.setter
    def X(self, value: Single) -> None: ...
    @property
    def Y(self) -> Single: ...
    @Y.setter
    def Y(self, value: Single) -> None: ...
    @property
    def Z(self) -> Single: ...
    @Z.setter
    def Z(self, value: Single) -> None: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def IsUnitVector(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, vector: Vector3f) -> bool: ...
    def EpsilonEquals(self, other: Vector3f, epsilon: Single) -> bool: ...
    def CompareTo(self, other: Vector3f) -> int: ...
    def GetHashCode(self) -> int: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Unitize(self) -> bool: ...
    def Transform(self, transformation: Transform) -> None: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3f) -> bool: ...
    def Reverse(self) -> bool: ...
    def PerpendicularTo(self, other: Vector3f) -> bool: ...
    def op_Equality(a: Vector3f, b: Vector3f) -> bool: ...
    def op_Inequality(a: Vector3f, b: Vector3f) -> bool: ...
    def op_LessThan(a: Vector3f, b: Vector3f) -> bool: ...
    def op_LessThanOrEqual(a: Vector3f, b: Vector3f) -> bool: ...
    def op_GreaterThan(a: Vector3f, b: Vector3f) -> bool: ...
    def op_GreaterThanOrEqual(a: Vector3f, b: Vector3f) -> bool: ...
    @overload
    def op_Addition(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    @overload
    def Add(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    @overload
    def op_Addition(point: Point3f, vector: Vector3f) -> Point3f: ...
    def op_UnaryNegation(vector: Vector3f) -> Vector3f: ...
    def op_Subtraction(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    def Subtract(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    def Negate(vector: Vector3f) -> Vector3f: ...
    @overload
    def Add(point: Point3f, vector: Vector3f) -> Point3f: ...
    @overload
    def op_Multiply(vector: Vector3f, t: Single) -> Vector3f: ...
    @overload
    def op_Multiply(point1: Vector3f, point2: Vector3f) -> float: ...
    @overload
    def Multiply(vector: Vector3f, t: Single) -> Vector3f: ...
    @overload
    def op_Multiply(t: Single, vector: Vector3f) -> Vector3f: ...
    @overload
    def Multiply(t: Single, vector: Vector3f) -> Vector3f: ...
    @overload
    def Multiply(point1: Vector3f, point2: Vector3f) -> float: ...
    @overload
    def op_Division(vector: Vector3f, t: float) -> Vector3f: ...
    @overload
    def op_Division(vector: Vector3f, t: Single) -> Vector3f: ...
    @overload
    def Divide(vector: Vector3f, t: float) -> Vector3f: ...
    @overload
    def Divide(vector: Vector3f, t: Single) -> Vector3f: ...
    def CrossProduct(a: Vector3f, b: Vector3f) -> Vector3f: ...
    @property
    def SquareLength(self) -> Single: ...
    @property
    def Length(self) -> Single: ...
    def op_Explicit(vector: Vector3d) -> Vector3f: ...


class Quaternion:
    def __init__(self, a: float, b: float, c: float, d: float): ...
    @property
    def Zero() -> Quaternion: ...
    @property
    def Identity() -> Quaternion: ...
    @property
    def I() -> Quaternion: ...
    @property
    def J() -> Quaternion: ...
    @property
    def K() -> Quaternion: ...
    def op_Equality(a: Quaternion, b: Quaternion) -> bool: ...
    def op_Inequality(a: Quaternion, b: Quaternion) -> bool: ...
    @overload
    def Equals(self, other: Quaternion) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    def EpsilonEquals(self, other: Quaternion, epsilon: float) -> bool: ...
    def GetHashCode(self) -> int: ...
    @property
    def A(self) -> float: ...
    @A.setter
    def A(self, value: float) -> None: ...
    @property
    def B(self) -> float: ...
    @B.setter
    def B(self, value: float) -> None: ...
    @property
    def C(self) -> float: ...
    @C.setter
    def C(self, value: float) -> None: ...
    @property
    def D(self) -> float: ...
    @D.setter
    def D(self, value: float) -> None: ...
    def Set(self, a: float, b: float, c: float, d: float) -> None: ...
    @overload
    def op_Multiply(q: Quaternion, x: int) -> Quaternion: ...
    @overload
    def op_Multiply(q: Quaternion, x: Single) -> Quaternion: ...
    @overload
    def op_Multiply(q: Quaternion, x: float) -> Quaternion: ...
    def op_Division(q: Quaternion, y: float) -> Quaternion: ...
    def op_Addition(a: Quaternion, b: Quaternion) -> Quaternion: ...
    def op_Subtraction(a: Quaternion, b: Quaternion) -> Quaternion: ...
    @overload
    def op_Multiply(a: Quaternion, b: Quaternion) -> Quaternion: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Conjugate(self) -> Quaternion: ...
    def Invert(self) -> bool: ...
    @property
    def Inverse(self) -> Quaternion: ...
    @property
    def Length(self) -> float: ...
    @property
    def LengthSquared(self) -> float: ...
    def DistanceTo(self, q: Quaternion) -> float: ...
    def Distance(p: Quaternion, q: Quaternion) -> float: ...
    def MatrixForm(self) -> Transform: ...
    def Unitize(self) -> bool: ...
    @overload
    def SetRotation(self, angle: float, axisOfRotation: Vector3d) -> None: ...
    @overload
    def Rotation(angle: float, axisOfRotation: Vector3d) -> Quaternion: ...
    @overload
    def SetRotation(self, plane0: Plane, plane1: Plane) -> None: ...
    @overload
    def Rotation(plane0: Plane, plane1: Plane) -> Quaternion: ...
    @overload
    def GetRotation(self) -> Tuple[bool, float, Vector3d]: ...
    @overload
    def GetRotation(self) -> Tuple[bool, Plane]: ...
    def Rotate(self, v: Vector3d) -> Vector3d: ...
    @property
    def Vector(self) -> Vector3d: ...
    @property
    def Scalar(self) -> float: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def IsScalar(self) -> bool: ...
    @property
    def IsVector(self) -> bool: ...
    def Product(p: Quaternion, q: Quaternion) -> Quaternion: ...
    def CrossProduct(p: Quaternion, q: Quaternion) -> Quaternion: ...


class Sphere:
    @overload
    def __init__(self, center: Point3d, radius: float): ...
    @overload
    def __init__(self, equatorialPlane: Plane, radius: float): ...
    @property
    def Unset() -> Sphere: ...
    def FitSphereToPoints(points: Iterable[Point3d]) -> Sphere: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Diameter(self) -> float: ...
    @Diameter.setter
    def Diameter(self, value: float) -> None: ...
    @property
    def Radius(self) -> float: ...
    @Radius.setter
    def Radius(self, value: float) -> None: ...
    @property
    def EquitorialPlane(self) -> Plane: ...
    @EquitorialPlane.setter
    def EquitorialPlane(self, value: Plane) -> None: ...
    @property
    def EquatorialPlane(self) -> Plane: ...
    @EquatorialPlane.setter
    def EquatorialPlane(self, value: Plane) -> None: ...
    @property
    def Center(self) -> Point3d: ...
    @Center.setter
    def Center(self, value: Point3d) -> None: ...
    @property
    def NorthPole(self) -> Point3d: ...
    @property
    def SouthPole(self) -> Point3d: ...
    def LatitudeRadians(self, radians: float) -> Circle: ...
    def LatitudeDegrees(self, degrees: float) -> Circle: ...
    def LongitudeRadians(self, radians: float) -> Circle: ...
    def LongitudeDegrees(self, degrees: float) -> Circle: ...
    def PointAt(self, longitudeRadians: float, latitudeRadians: float) -> Point3d: ...
    def NormalAt(self, longitudeRadians: float, latitudeRadians: float) -> Vector3d: ...
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    def ClosestParameter(self, testPoint: Point3d) -> Tuple[bool, float, float]: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, axisOfRotation: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, axisOfRotation: Vector3d, centerOfRotation: Point3d) -> bool: ...
    def Translate(self, delta: Vector3d) -> bool: ...
    def Transform(self, xform: Transform) -> bool: ...
    def ToBrep(self) -> Brep: ...
    def ToNurbsSurface(self) -> NurbsSurface: ...
    def ToRevSurface(self) -> RevSurface: ...
    def EpsilonEquals(self, other: Sphere, epsilon: float) -> bool: ...


class Torus:
    def __init__(self, basePlane: Plane, majorRadius: float, minorRadius: float): ...
    @property
    def Unset() -> Torus: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @Plane.setter
    def Plane(self, value: Plane) -> None: ...
    @property
    def MajorRadius(self) -> float: ...
    @MajorRadius.setter
    def MajorRadius(self, value: float) -> None: ...
    @property
    def MinorRadius(self) -> float: ...
    @MinorRadius.setter
    def MinorRadius(self, value: float) -> None: ...
    def ToNurbsSurface(self) -> NurbsSurface: ...
    def ToRevSurface(self) -> RevSurface: ...
    def EpsilonEquals(self, other: Torus, epsilon: float) -> bool: ...


class Transform:
    @overload
    def __init__(self, diagonalValue: float): ...
    @overload
    def __init__(self, value: Transform): ...
    def Linearize(self) -> None: ...
    def Orthogonalize(self, tolerance: float) -> bool: ...
    def DecomposeSymmetric(self) -> Tuple[bool, Transform, Vector3d]: ...
    @property
    def Determinant(self) -> float: ...
    def GetYawPitchRoll(self) -> Tuple[bool, float, float, float]: ...
    def GetEulerZYZ(self) -> Tuple[bool, float, float, float]: ...
    def TransformBoundingBox(self, bbox: BoundingBox) -> BoundingBox: ...
    def TransformList(self, points: Iterable[Point3d]) -> Set(Point3d): ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, other: Transform) -> bool: ...
    def GetHashCode(self) -> int: ...
    def ToString(self) -> str: ...
    def TryGetInverse(self) -> Tuple[bool, Transform]: ...
    def Transpose(self) -> Transform: ...
    def ToFloatArray(self, rowDominant: bool) -> Set(Single): ...
    def Clone(self) -> Transform: ...
    def CompareTo(self, other: Transform) -> int: ...
    @property
    def Identity() -> Transform: ...
    @property
    def ZeroTransformation() -> Transform: ...
    @property
    def Unset() -> Transform: ...
    def RotationZYX(yaw: float, pitch: float, roll: float) -> Transform: ...
    def RotationZYZ(alpha: float, beta: float, gamma: float) -> Transform: ...
    @overload
    def Translation(motion: Vector3d) -> Transform: ...
    @overload
    def Translation(dx: float, dy: float, dz: float) -> Transform: ...
    @overload
    def Diagonal(diagonal: Vector3d) -> Transform: ...
    @overload
    def Diagonal(d0: float, d1: float, d2: float) -> Transform: ...
    @overload
    def Scale(anchor: Point3d, scaleFactor: float) -> Transform: ...
    @overload
    def Scale(plane: Plane, xScaleFactor: float, yScaleFactor: float, zScaleFactor: float) -> Transform: ...
    @overload
    def Rotation(sinAngle: float, cosAngle: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    def Rotation(angleRadians: float, rotationCenter: Point3d) -> Transform: ...
    @overload
    def Rotation(angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    def Rotation(startDirection: Vector3d, endDirection: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    def Rotation(x0: Vector3d, y0: Vector3d, z0: Vector3d, x1: Vector3d, y1: Vector3d, z1: Vector3d) -> Transform: ...
    @overload
    def Mirror(pointOnMirrorPlane: Point3d, normalToMirrorPlane: Vector3d) -> Transform: ...
    @overload
    def Mirror(mirrorPlane: Plane) -> Transform: ...
    @overload
    def ChangeBasis(plane0: Plane, plane1: Plane) -> Transform: ...
    def PlaneToPlane(plane0: Plane, plane1: Plane) -> Transform: ...
    @overload
    def ChangeBasis(initialBasisX: Vector3d, initialBasisY: Vector3d, initialBasisZ: Vector3d, finalBasisX: Vector3d, finalBasisY: Vector3d, finalBasisZ: Vector3d) -> Transform: ...
    def PlanarProjection(plane: Plane) -> Transform: ...
    def ProjectAlong(plane: Plane, direction: Vector3d) -> Transform: ...
    def Shear(plane: Plane, x: Vector3d, y: Vector3d, z: Vector3d) -> Transform: ...
    def op_Equality(a: Transform, b: Transform) -> bool: ...
    def op_Inequality(a: Transform, b: Transform) -> bool: ...
    @overload
    def op_Multiply(a: Transform, b: Transform) -> Transform: ...
    @overload
    def op_Multiply(m: Transform, p: Point3d) -> Point3d: ...
    @overload
    def op_Multiply(m: Transform, v: Vector3d) -> Vector3d: ...
    def Multiply(a: Transform, b: Transform) -> Transform: ...
    @property
    def M00(self) -> float: ...
    @M00.setter
    def M00(self, value: float) -> None: ...
    @property
    def M01(self) -> float: ...
    @M01.setter
    def M01(self, value: float) -> None: ...
    @property
    def M02(self) -> float: ...
    @M02.setter
    def M02(self, value: float) -> None: ...
    @property
    def M03(self) -> float: ...
    @M03.setter
    def M03(self, value: float) -> None: ...
    @property
    def M10(self) -> float: ...
    @M10.setter
    def M10(self, value: float) -> None: ...
    @property
    def M11(self) -> float: ...
    @M11.setter
    def M11(self, value: float) -> None: ...
    @property
    def M12(self) -> float: ...
    @M12.setter
    def M12(self, value: float) -> None: ...
    @property
    def M13(self) -> float: ...
    @M13.setter
    def M13(self, value: float) -> None: ...
    @property
    def M20(self) -> float: ...
    @M20.setter
    def M20(self, value: float) -> None: ...
    @property
    def M21(self) -> float: ...
    @M21.setter
    def M21(self, value: float) -> None: ...
    @property
    def M22(self) -> float: ...
    @M22.setter
    def M22(self, value: float) -> None: ...
    @property
    def M23(self) -> float: ...
    @M23.setter
    def M23(self, value: float) -> None: ...
    @property
    def M30(self) -> float: ...
    @M30.setter
    def M30(self, value: float) -> None: ...
    @property
    def M31(self) -> float: ...
    @M31.setter
    def M31(self, value: float) -> None: ...
    @property
    def M32(self) -> float: ...
    @M32.setter
    def M32(self, value: float) -> None: ...
    @property
    def M33(self) -> float: ...
    @M33.setter
    def M33(self, value: float) -> None: ...
    @property
    def Item(self, row: int, column: int) -> float: ...
    @Item.setter
    def Item(self, row: int, column: int, value: float) -> None: ...
    @property
    def IsIdentity(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def IsZero4x4(self) -> bool: ...
    @property
    def IsZeroTransformation(self) -> bool: ...
    def IsZeroTransformaton(self, zeroTolerance: float) -> bool: ...
    @property
    def SimilarityType(self) -> TransformSimilarityType: ...
    def IsSimilarity(self, tolerance: float) -> TransformSimilarityType: ...
    def DecomposeSimilarity(self, tolerance: float) -> Tuple[TransformSimilarityType, Vector3d, float, Transform]: ...
    @property
    def RigidType(self) -> TransformRigidType: ...
    def IsRigid(self, tolerance: float) -> TransformRigidType: ...
    def DecomposeRigid(self, tolerance: float) -> Tuple[TransformRigidType, Vector3d, Transform]: ...
    @property
    def IsAffine(self) -> bool: ...
    @property
    def IsLinear(self) -> bool: ...
    @overload
    def DecomposeAffine(self) -> Tuple[bool, Vector3d, Transform]: ...
    @overload
    def DecomposeAffine(self) -> Tuple[bool, Transform, Vector3d]: ...
    @overload
    def DecomposeAffine(self) -> Tuple[bool, Vector3d, Transform, Transform, Vector3d]: ...
    @property
    def IsRotation(self) -> bool: ...
    def Affineize(self) -> None: ...


class TransformSimilarityType:
    NotSimilarity = 0
    OrientationPreserving = 1
    OrientationReversing = -1


class TransformRigidType:
    NotRigid = 0
    Rigid = 1
    RigidReversing = -1


class SpaceMorph:
    @overload
    def Morph(self, geometry: GeometryBase) -> bool: ...
    @overload
    def Morph(self, plane: Plane) -> Tuple[bool, Plane]: ...
    def IsMorphable(geometry: GeometryBase) -> bool: ...
    def MorphPoint(self, point: Point3d) -> Point3d: ...
    @property
    def Tolerance(self) -> float: ...
    @Tolerance.setter
    def Tolerance(self, value: float) -> None: ...
    @property
    def QuickPreview(self) -> bool: ...
    @QuickPreview.setter
    def QuickPreview(self, value: bool) -> None: ...
    @property
    def PreserveStructure(self) -> bool: ...
    @PreserveStructure.setter
    def PreserveStructure(self, value: bool) -> None: ...


class Interval:
    @overload
    def __init__(self, t0: float, t1: float): ...
    @overload
    def __init__(self, other: Interval): ...
    def op_Equality(a: Interval, b: Interval) -> bool: ...
    def op_Inequality(a: Interval, b: Interval) -> bool: ...
    @overload
    def op_Addition(interval: Interval, number: float) -> Interval: ...
    @overload
    def op_Addition(number: float, interval: Interval) -> Interval: ...
    @overload
    def op_Subtraction(interval: Interval, number: float) -> Interval: ...
    @overload
    def op_Subtraction(number: float, interval: Interval) -> Interval: ...
    def op_LessThan(a: Interval, b: Interval) -> bool: ...
    def op_LessThanOrEqual(a: Interval, b: Interval) -> bool: ...
    def op_GreaterThan(a: Interval, b: Interval) -> bool: ...
    def op_GreaterThanOrEqual(a: Interval, b: Interval) -> bool: ...
    @property
    def Unset() -> Interval: ...
    @property
    def T0(self) -> float: ...
    @T0.setter
    def T0(self, value: float) -> None: ...
    @property
    def T1(self) -> float: ...
    @T1.setter
    def T1(self, value: float) -> None: ...
    @property
    def Item(self, index: int) -> float: ...
    @Item.setter
    def Item(self, index: int, value: float) -> None: ...
    @property
    def Min(self) -> float: ...
    @property
    def Max(self) -> float: ...
    @property
    def Mid(self) -> float: ...
    @property
    def Length(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsSingleton(self) -> bool: ...
    @property
    def IsIncreasing(self) -> bool: ...
    @property
    def IsDecreasing(self) -> bool: ...
    def GetHashCode(self) -> int: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, other: Interval) -> bool: ...
    def CompareTo(self, other: Interval) -> int: ...
    def ToString(self) -> str: ...
    def Grow(self, value: float) -> None: ...
    def MakeIncreasing(self) -> None: ...
    def Reverse(self) -> None: ...
    def Swap(self) -> None: ...
    def ParameterAt(self, normalizedParameter: float) -> float: ...
    def ParameterIntervalAt(self, normalizedInterval: Interval) -> Interval: ...
    def NormalizedParameterAt(self, intervalParameter: float) -> float: ...
    def NormalizedIntervalAt(self, intervalParameter: Interval) -> Interval: ...
    @overload
    def IncludesParameter(self, t: float) -> bool: ...
    @overload
    def IncludesParameter(self, t: float, strict: bool) -> bool: ...
    @overload
    def IncludesInterval(self, interval: Interval) -> bool: ...
    @overload
    def IncludesInterval(self, interval: Interval, strict: bool) -> bool: ...
    def FromIntersection(a: Interval, b: Interval) -> Interval: ...
    def FromUnion(a: Interval, b: Interval) -> Interval: ...
    def EpsilonEquals(self, other: Interval, epsilon: float) -> bool: ...


class Point2d:
    @overload
    def __init__(self, x: float, y: float): ...
    @overload
    def __init__(self, vector: Vector2d): ...
    @overload
    def __init__(self, point: Point2d): ...
    @overload
    def __init__(self, point: Point3d): ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> None: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> None: ...
    @overload
    def op_Multiply(point: Point2d, t: float) -> Point2d: ...
    @overload
    def Multiply(point: Point2d, t: float) -> Point2d: ...
    @overload
    def op_Multiply(t: float, point: Point2d) -> Point2d: ...
    @overload
    def Multiply(t: float, point: Point2d) -> Point2d: ...
    def op_Division(point: Point2d, t: float) -> Point2d: ...
    def Divide(point: Point2d, t: float) -> Point2d: ...
    @overload
    def op_Addition(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    def Add(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    def op_Addition(vector: Vector2d, point: Point2d) -> Point2d: ...
    @overload
    def Add(vector: Vector2d, point: Point2d) -> Point2d: ...
    @overload
    def op_Addition(point1: Point2d, point2: Point2d) -> Point2d: ...
    @overload
    def Add(point1: Point2d, point2: Point2d) -> Point2d: ...
    @overload
    def op_Subtraction(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    def Subtract(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    def op_Subtraction(point1: Point2d, point2: Point2d) -> Vector2d: ...
    @overload
    def Subtract(point1: Point2d, point2: Point2d) -> Vector2d: ...
    def op_Equality(a: Point2d, b: Point2d) -> bool: ...
    def op_Inequality(a: Point2d, b: Point2d) -> bool: ...
    def op_LessThan(a: Point2d, b: Point2d) -> bool: ...
    def op_LessThanOrEqual(a: Point2d, b: Point2d) -> bool: ...
    def op_GreaterThan(a: Point2d, b: Point2d) -> bool: ...
    def op_GreaterThanOrEqual(a: Point2d, b: Point2d) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, point: Point2d) -> bool: ...
    def GetHashCode(self) -> int: ...
    def CompareTo(self, other: Point2d) -> int: ...
    def EpsilonEquals(self, other: Point2d, epsilon: float) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @property
    def Item(self, index: int) -> float: ...
    @Item.setter
    def Item(self, index: int, value: float) -> None: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def MinimumCoordinate(self) -> float: ...
    @property
    def MaximumCoordinate(self) -> float: ...
    @property
    def Origin() -> Point2d: ...
    @property
    def Unset() -> Point2d: ...
    def DistanceTo(self, other: Point2d) -> float: ...
    def Transform(self, xform: Transform) -> None: ...


class Point3d:
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    def __init__(self, vector: Vector3d): ...
    @overload
    def __init__(self, point: Point3f): ...
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, point: Point4d): ...
    @property
    def Origin() -> Point3d: ...
    @property
    def Unset() -> Point3d: ...
    @overload
    def op_Multiply(point: Point3d, t: float) -> Point3d: ...
    @overload
    def Multiply(point: Point3d, t: float) -> Point3d: ...
    @overload
    def op_Multiply(t: float, point: Point3d) -> Point3d: ...
    @overload
    def Multiply(t: float, point: Point3d) -> Point3d: ...
    def op_Division(point: Point3d, t: float) -> Point3d: ...
    def Divide(point: Point3d, t: float) -> Point3d: ...
    @overload
    def op_Addition(point1: Point3d, point2: Point3d) -> Point3d: ...
    @overload
    def Add(point1: Point3d, point2: Point3d) -> Point3d: ...
    @overload
    def op_Addition(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    def Add(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    def op_Addition(point: Point3d, vector: Vector3f) -> Point3d: ...
    @overload
    def Add(point: Point3d, vector: Vector3f) -> Point3d: ...
    @overload
    def op_Addition(vector: Vector3d, point: Point3d) -> Point3d: ...
    @overload
    def Add(vector: Vector3d, point: Point3d) -> Point3d: ...
    @overload
    def op_Subtraction(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    def Subtract(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    def op_Subtraction(point1: Point3d, point2: Point3d) -> Vector3d: ...
    @overload
    def Subtract(point1: Point3d, point2: Point3d) -> Vector3d: ...
    def op_UnaryNegation(point: Point3d) -> Point3d: ...
    def op_Equality(a: Point3d, b: Point3d) -> bool: ...
    def op_Inequality(a: Point3d, b: Point3d) -> bool: ...
    @overload
    def op_Implicit(pt: Point3d) -> ControlPoint: ...
    @overload
    def op_Explicit(point: Point3d) -> Vector3d: ...
    @overload
    def op_Explicit(vector: Vector3d) -> Point3d: ...
    @overload
    def op_Implicit(point: Point3f) -> Point3d: ...
    def FromPoint3f(point: Point3f) -> Point3d: ...
    def op_LessThan(a: Point3d, b: Point3d) -> bool: ...
    def op_LessThanOrEqual(a: Point3d, b: Point3d) -> bool: ...
    def op_GreaterThan(a: Point3d, b: Point3d) -> bool: ...
    def op_GreaterThanOrEqual(a: Point3d, b: Point3d) -> bool: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> None: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> None: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> None: ...
    @property
    def Item(self, index: int) -> float: ...
    @Item.setter
    def Item(self, index: int, value: float) -> None: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def MinimumCoordinate(self) -> float: ...
    @property
    def MaximumCoordinate(self) -> float: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    def EpsilonEquals(self, other: Point3d, epsilon: float) -> bool: ...
    def CompareTo(self, other: Point3d) -> int: ...
    @overload
    def Equals(self, point: Point3d) -> bool: ...
    def GetHashCode(self) -> int: ...
    def Interpolate(self, pA: Point3d, pB: Point3d, t: float) -> None: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def DistanceTo(self, other: Point3d) -> float: ...
    def DistanceToSquared(self, other: Point3d) -> float: ...
    def Transform(self, xform: Transform) -> None: ...
    def CullDuplicates(points: Iterable[Point3d], tolerance: float) -> Set(Point3d): ...
    def ArePointsCoplanar(points: Iterable[Point3d], tolerance: float) -> bool: ...
    def TryParse(input: str) -> Tuple[bool, Point3d]: ...
    def SortAndCullPointList(points: Iterable[Point3d], minimumDistance: float) -> Set(Point3d): ...


class Point4d:
    @overload
    def __init__(self, x: float, y: float, z: float, w: float): ...
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, point: Point4d): ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> None: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> None: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> None: ...
    @property
    def W(self) -> float: ...
    @W.setter
    def W(self, value: float) -> None: ...
    def op_Addition(point1: Point4d, point2: Point4d) -> Point4d: ...
    def Add(point1: Point4d, point2: Point4d) -> Point4d: ...
    def op_Subtraction(point1: Point4d, point2: Point4d) -> Point4d: ...
    def Subtract(point1: Point4d, point2: Point4d) -> Point4d: ...
    @overload
    def op_Multiply(point: Point4d, d: float) -> Point4d: ...
    def Multiply(point: Point4d, d: float) -> Point4d: ...
    @overload
    def op_Multiply(point1: Point4d, point2: Point4d) -> float: ...
    def op_Equality(a: Point4d, b: Point4d) -> bool: ...
    def op_Inequality(a: Point4d, b: Point4d) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, point: Point4d) -> bool: ...
    def EpsilonEquals(self, other: Point4d, epsilon: float) -> bool: ...
    def GetHashCode(self) -> int: ...
    @property
    def Unset() -> Point4d: ...
    def Transform(self, xform: Transform) -> None: ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...


class Vector2d:
    def __init__(self, x: float, y: float): ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> None: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> None: ...
    @property
    def Length(self) -> float: ...
    @overload
    def op_Multiply(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    def op_Multiply(t: float, vector: Vector2d) -> Vector2d: ...
    @overload
    def Multiply(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    def Multiply(t: float, vector: Vector2d) -> Vector2d: ...
    def op_Division(vector: Vector2d, t: float) -> Vector2d: ...
    def Divide(vector: Vector2d, t: float) -> Vector2d: ...
    def op_Addition(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    def Add(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    def op_Subtraction(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    def Subtract(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    @overload
    def op_Multiply(vector1: Vector2d, vector2: Vector2d) -> float: ...
    @overload
    def Multiply(vector1: Vector2d, vector2: Vector2d) -> float: ...
    def op_UnaryNegation(vector: Vector2d) -> Vector2d: ...
    def Negate(vector: Vector2d) -> Vector2d: ...
    def op_Equality(a: Vector2d, b: Vector2d) -> bool: ...
    def op_Inequality(a: Vector2d, b: Vector2d) -> bool: ...
    def op_LessThan(a: Vector2d, b: Vector2d) -> bool: ...
    def op_LessThanOrEqual(a: Vector2d, b: Vector2d) -> bool: ...
    def op_GreaterThan(a: Vector2d, b: Vector2d) -> bool: ...
    def op_GreaterThanOrEqual(a: Vector2d, b: Vector2d) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, vector: Vector2d) -> bool: ...
    def EpsilonEquals(self, other: Vector2d, epsilon: float) -> bool: ...
    def CompareTo(self, other: Vector2d) -> int: ...
    def GetHashCode(self) -> int: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    @property
    def Zero() -> Vector2d: ...
    @property
    def Unset() -> Vector2d: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def SquareLength(self) -> float: ...
    @overload
    def IsTiny(self, tolerance: float) -> bool: ...
    @overload
    def IsTiny(self) -> bool: ...
    def Unitize(self) -> bool: ...
    def Rotate(self, angleRadians: float) -> bool: ...


class Vector3d:
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, vector: Vector3f): ...
    @overload
    def __init__(self, vector: Vector3d): ...
    @property
    def Zero() -> Vector3d: ...
    @property
    def XAxis() -> Vector3d: ...
    @property
    def YAxis() -> Vector3d: ...
    @property
    def ZAxis() -> Vector3d: ...
    @property
    def Unset() -> Vector3d: ...
    @overload
    def op_Multiply(vector: Vector3d, t: float) -> Vector3d: ...
    @overload
    def Multiply(vector: Vector3d, t: float) -> Vector3d: ...
    @overload
    def op_Multiply(t: float, vector: Vector3d) -> Vector3d: ...
    @overload
    def Multiply(t: float, vector: Vector3d) -> Vector3d: ...
    def op_Division(vector: Vector3d, t: float) -> Vector3d: ...
    def Divide(vector: Vector3d, t: float) -> Vector3d: ...
    def op_Addition(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    def Add(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    def op_Subtraction(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    def Subtract(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    @overload
    def op_Multiply(vector1: Vector3d, vector2: Vector3d) -> float: ...
    @overload
    def Multiply(vector1: Vector3d, vector2: Vector3d) -> float: ...
    def op_UnaryNegation(vector: Vector3d) -> Vector3d: ...
    def Negate(vector: Vector3d) -> Vector3d: ...
    def op_Equality(a: Vector3d, b: Vector3d) -> bool: ...
    def op_Inequality(a: Vector3d, b: Vector3d) -> bool: ...
    def CrossProduct(a: Vector3d, b: Vector3d) -> Vector3d: ...
    @overload
    def VectorAngle(a: Vector3d, b: Vector3d) -> float: ...
    @overload
    def VectorAngle(a: Vector3d, b: Vector3d, plane: Plane) -> float: ...
    @overload
    def VectorAngle(v1: Vector3d, v2: Vector3d, vNormal: Vector3d) -> float: ...
    def op_Implicit(vector: Vector3f) -> Vector3d: ...
    def op_LessThan(a: Vector3d, b: Vector3d) -> bool: ...
    def op_LessThanOrEqual(a: Vector3d, b: Vector3d) -> bool: ...
    def op_GreaterThan(a: Vector3d, b: Vector3d) -> bool: ...
    def op_GreaterThanOrEqual(a: Vector3d, b: Vector3d) -> bool: ...
    def AreOrthogonal(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    def AreOrthonormal(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    def AreRighthanded(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> None: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> None: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> None: ...
    @property
    def Item(self, index: int) -> float: ...
    @Item.setter
    def Item(self, index: int, value: float) -> None: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def MinimumCoordinate(self) -> float: ...
    @property
    def MaximumCoordinate(self) -> float: ...
    @property
    def Length(self) -> float: ...
    @property
    def SquareLength(self) -> float: ...
    @property
    def IsUnitVector(self) -> bool: ...
    @overload
    def IsTiny(self, tolerance: float) -> bool: ...
    @overload
    def IsTiny(self) -> bool: ...
    @property
    def IsZero(self) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, vector: Vector3d) -> bool: ...
    def EpsilonEquals(self, other: Vector3d, epsilon: float) -> bool: ...
    def CompareTo(self, other: Vector3d) -> int: ...
    def GetHashCode(self) -> int: ...
    @overload
    def ToString(self) -> str: ...
    @overload
    def ToString(self, format: str, formatProvider: IFormatProvider) -> str: ...
    def Unitize(self) -> bool: ...
    def Transform(self, transformation: Transform) -> None: ...
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d) -> bool: ...
    def Reverse(self) -> bool: ...
    @overload
    def IsParallelTo(self, other: Vector3d) -> int: ...
    @overload
    def IsParallelTo(self, other: Vector3d, angleTolerance: float) -> int: ...
    @overload
    def IsPerpendicularTo(self, other: Vector3d) -> bool: ...
    @overload
    def IsPerpendicularTo(self, other: Vector3d, angleTolerance: float) -> bool: ...
    def PerpendicularTo(self, other: Vector3d) -> bool: ...


class Ray3d:
    def __init__(self, position: Point3d, direction: Vector3d): ...
    @property
    def Position(self) -> Point3d: ...
    @property
    def Direction(self) -> Vector3d: ...
    def PointAt(self, t: float) -> Point3d: ...
    def op_Equality(a: Ray3d, b: Ray3d) -> bool: ...
    def op_Inequality(a: Ray3d, b: Ray3d) -> bool: ...
    @overload
    def Equals(self, obj: Object) -> bool: ...
    @overload
    def Equals(self, ray: Ray3d) -> bool: ...
    def EpsilonEquals(self, other: Ray3d, epsilon: float) -> bool: ...
    def GetHashCode(self) -> int: ...


class Continuity:
    #None = 0
    C0_continuous = 1
    C1_continuous = 2
    C2_continuous = 3
    G1_continuous = 4
    G2_continuous = 5
    C0_locus_continuous = 6
    C1_locus_continuous = 7
    C2_locus_continuous = 8
    G1_locus_continuous = 9
    G2_locus_continuous = 10
    Cinfinity_continuous = 11
    Gsmooth_continuous = 12


class MeshType:
    Default = 0
    Render = 1
    Analysis = 2
    Preview = 3
    Any = 4


class LightStyle:
    #None = 0
    CameraDirectional = 4
    CameraPoint = 5
    CameraSpot = 6
    WorldDirectional = 7
    WorldPoint = 8
    WorldSpot = 9
    Ambient = 10
    WorldLinear = 11
    WorldRectangular = 12


class ComponentIndexType:
    InvalidType = 0
    BrepVertex = 1
    BrepEdge = 2
    BrepFace = 3
    BrepTrim = 4
    BrepLoop = 5
    MeshVertex = 11
    MeshTopologyVertex = 12
    MeshTopologyEdge = 13
    MeshFace = 14
    MeshNgon = 15
    InstanceDefinitionPart = 21
    PolycurveSegment = 31
    PointCloudPoint = 41
    GroupMember = 51
    ExtrusionBottomProfile = 61
    ExtrusionTopProfile = 62
    ExtrusionWallEdge = 63
    ExtrusionWallSurface = 64
    ExtrusionCapSurface = 65
    ExtrusionPath = 66
    SubdVertex = 71
    SubdEdge = 72
    SubdFace = 73
    DimLinearPoint = 100
    DimRadialPoint = 101
    DimAngularPoint = 102
    DimOrdinatePoint = 103
    DimTextPoint = 104
    NoType = 268435455


class ComponentIndex:
    def __init__(self, type: ComponentIndexType, index: int): ...
    @property
    def ComponentIndexType(self) -> ComponentIndexType: ...
    @property
    def Index(self) -> int: ...
    def IsUnset(self) -> bool: ...
    @property
    def Unset() -> ComponentIndex: ...


class SweepOneRail:
    def __init__(self): ...
    @property
    def IsFreeform(self) -> bool: ...
    @property
    def IsRoadlike(self) -> bool: ...
    @property
    def IsRoadlikeTop(self) -> bool: ...
    @property
    def IsRoadlikeFront(self) -> bool: ...
    @property
    def IsRoadlineRight(self) -> bool: ...
    def SetToRoadlikeTop(self) -> None: ...
    def SetToRoadlikeFront(self) -> None: ...
    def SetToRoadlikeRight(self) -> None: ...
    def SetRoadlikeUpDirection(self, up: Vector3d) -> None: ...
    @property
    def SweepTolerance(self) -> float: ...
    @SweepTolerance.setter
    def SweepTolerance(self, value: float) -> None: ...
    @property
    def AngleToleranceRadians(self) -> float: ...
    @AngleToleranceRadians.setter
    def AngleToleranceRadians(self, value: float) -> None: ...
    @property
    def MiterType(self) -> int: ...
    @MiterType.setter
    def MiterType(self, value: int) -> None: ...
    @property
    def ClosedSweep(self) -> bool: ...
    @ClosedSweep.setter
    def ClosedSweep(self, value: bool) -> None: ...
    @property
    def GlobalShapeBlending(self) -> bool: ...
    @GlobalShapeBlending.setter
    def GlobalShapeBlending(self, value: bool) -> None: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSection: Curve) -> Set(Brep): ...
    @overload
    def PerformSweep(self, rail: Curve, crossSection: Curve, crossSectionParameter: float) -> Set(Brep): ...
    @overload
    def PerformSweep(self, rail: Curve, crossSections: Iterable[Curve]) -> Set(Brep): ...
    @overload
    def PerformSweep(self, rail: Curve, crossSections: Iterable[Curve], crossSectionParameters: Iterable[float]) -> Set(Brep): ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSection: Curve, refitTolerance: float) -> Set(Brep): ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSection: Curve, crossSectionParameter: float, refitTolerance: float) -> Set(Brep): ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSections: Iterable[Curve], refitTolerance: float) -> Set(Brep): ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSections: Iterable[Curve], crossSectionParameters: Iterable[float], refitTolerance: float) -> Set(Brep): ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSection: Curve, rebuildCount: int) -> Set(Brep): ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSection: Curve, crossSectionParameter: float, rebuildCount: int) -> Set(Brep): ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSections: Iterable[Curve], rebuildCount: int) -> Set(Brep): ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSections: Iterable[Curve], crossSectionParameters: Iterable[float], rebuildCount: int) -> Set(Brep): ...


class SweepTwoRail:
    def __init__(self): ...
    @property
    def SweepTolerance(self) -> float: ...
    @SweepTolerance.setter
    def SweepTolerance(self, value: float) -> None: ...
    @property
    def AngleToleranceRadians(self) -> float: ...
    @AngleToleranceRadians.setter
    def AngleToleranceRadians(self, value: float) -> None: ...
    @property
    def MaintainHeight(self) -> bool: ...
    @MaintainHeight.setter
    def MaintainHeight(self, value: bool) -> None: ...
    @property
    def ClosedSweep(self) -> bool: ...
    @ClosedSweep.setter
    def ClosedSweep(self, value: bool) -> None: ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSection: Curve) -> Set(Brep): ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float) -> Set(Brep): ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve]) -> Set(Brep): ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], crossSectionParameters1: Iterable[float], crossSectionParameters2: Iterable[float]) -> Set(Brep): ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSection: Curve, refitTolerance: float) -> Set(Brep): ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float, refitTolerance: float) -> Set(Brep): ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], refitTolerance: float) -> Set(Brep): ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], crossSectionParametersRail1: Iterable[float], crossSectionParametersRail2: Iterable[float], refitTolerance: float) -> Set(Brep): ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSection: Curve, rebuildCount: int) -> Set(Brep): ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float, rebuildCount: int) -> Set(Brep): ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], rebuildCount: int) -> Set(Brep): ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSections: Iterable[Curve], crossSectionParametersRail1: Iterable[float], crossSectionParametersRail2: Iterable[float], rebuildCount: int) -> Set(Brep): ...


class Unroller:
    @overload
    def __init__(self, surface: Surface): ...
    @overload
    def __init__(self, brep: Brep): ...
    @overload
    def AddFollowingGeometry(self, curves: Iterable[Curve]) -> None: ...
    @overload
    def AddFollowingGeometry(self, curve: Curve) -> None: ...
    @overload
    def AddFollowingGeometry(self, points: Iterable[Point3d]) -> None: ...
    @overload
    def AddFollowingGeometry(self, point: Point3d) -> None: ...
    @overload
    def AddFollowingGeometry(self, point: Point) -> None: ...
    @overload
    def AddFollowingGeometry(self, dots: Iterable[TextDot]) -> None: ...
    @overload
    def AddFollowingGeometry(self, dot: TextDot) -> None: ...
    @overload
    def AddFollowingGeometry(self, dotLocations: Iterable[Point3d], dotText: Iterable[str]) -> None: ...
    @overload
    def AddFollowingGeometry(self, dotLocation: Point3d, dotText: str) -> None: ...
    @property
    def ExplodeOutput(self) -> bool: ...
    @ExplodeOutput.setter
    def ExplodeOutput(self, value: bool) -> None: ...
    @property
    def ExplodeSpacing(self) -> float: ...
    @ExplodeSpacing.setter
    def ExplodeSpacing(self, value: float) -> None: ...
    @property
    def AbsoluteTolerance(self) -> float: ...
    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, value: float) -> None: ...
    @property
    def RelativeTolerance(self) -> float: ...
    @RelativeTolerance.setter
    def RelativeTolerance(self, value: float) -> None: ...
    @overload
    def PerformUnroll(self) -> Tuple[Set(Brep), Set(Curve), Set(Point3d), Set(TextDot)]: ...
    @overload
    def PerformUnroll(self, flatbreps: List) -> int: ...
    @overload
    def FollowingGeometryIndex(self, dot: TextDot) -> int: ...
    @overload
    def FollowingGeometryIndex(self, curve: Curve) -> int: ...


class DevelopableSrf:
    def __init__(self): ...
    def GetLocalDevopableRuling(rail0: NurbsCurve, t0: float, dom0: Interval, rail1: NurbsCurve, t1: float, dom1: Interval, t0_out: float, t1_out: float) -> Tuple[int, float, float]: ...
    @overload
    def RulingMinTwist(rail0: NurbsCurve, t0: float, rail1: NurbsCurve, t1: float, dom1: Interval, t1_out: float, cos_twist_out: float) -> Tuple[bool, float, float]: ...
    @overload
    def RulingMinTwist(rail0: NurbsCurve, t0: float, dom0: Interval, rail1: NurbsCurve, t1: float, dom1: Interval, t0_out: float, t1_out: float, cos_twist_out: float) -> Tuple[bool, float, float, float]: ...
    def UntwistRulings(rail0: NurbsCurve, rail1: NurbsCurve, rulings: Iterable[Point2d]) -> Tuple[bool, Iterable[Point2d]]: ...


class ForceArrow:
    Auto = 0
    Inside = 1
    Outside = 2


class ForceText:
    Auto = 0
    Inside = 1
    Right = 2
    Left = 3
    HintRight = 4
    HintLeft = 5


class MeasuredDirection:
    Unset = 0
    Xaxis = 1
    Yaxis = 2


class NurbsSurfaceType:
    Unset = 0
    Large = 1
    Medium = 2
    Small = 3
    Unprocessed = 4


class InteriorCreaseOption:
    Unset = 0
    #None = 1
    AtMeshCrease = 2
    AtMeshEdge = 3


class ConvexCornerOption:
    Unset = 0
    #None = 1
    AtMeshCorner = 2


class ShrinkDisableSide:
    ShrinkAllSides = 0
    DoNotShrinkWestSide = 1
    DoNotShrinkSouthSide = 2
    DoNotShrinkEastSide = 4
    DoNotShrinkNorthSide = 8


class Visibility:
    Unset = 0
    Visible = 1
    Hidden = 2
    Duplicate = 3


class Visibility:
    Unset = 0
    Visible = 1
    Hidden = 2
    Duplicate = 3
    Projecting = 4
    Clipped = 5


class SideFill:
    SideUnset = 0
    SideSurface = 1
    SideVoid = 2
    OtherSurface = 3


class NurbsCurveEndConditionType:
    Nothing = 0
    Position = 1
    Tangency = 2
    Curvature = 3
